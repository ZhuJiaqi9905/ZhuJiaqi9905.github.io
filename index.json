[
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%90%9C%E7%B4%A2/%E5%85%A8%E6%8E%92%E5%88%97/",
	"title": "全排列",
	"tags": [],
	"description": "",
	"content": "题目描述 求1~n的全排列\n解题思路  用dfs枚举全排列  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int result[200]; int N; int used[200]; /*用dfs生成全排列*/ void permutation1(int k); /*优化后的全排列生成,但不是按顺序生成的， 思路： 求 S = {a1,a2,a3..an}的全排列，等于: for (int i = 1; i \u0026lt;= n; ++i ) { for x in (S – ai) 的每个排列 cout \u0026lt;\u0026lt; ai + x; } */ template\u0026lt;class T\u0026gt; void permutation2(T start, T end, T k) { //输出[start,k)固定的全排列 if (k == end) { for (start; start != end; ++start) { cout \u0026lt;\u0026lt; *start \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; return; } for (T i = k; i != end; ++i) { swap(*k, *i); permutation2(start, end, k + 1); swap(*k, *i); } } int a[200]; int main() { cin \u0026gt;\u0026gt; N; permutation1(0); for (int i = 0; i \u0026lt; N; ++i) { a[i] = i + 1; } permutation2(a, a + N, a); return 0; } void permutation1(int k) { if (k == N) { for (int i = 0; i \u0026lt; N; ++i) { cout \u0026lt;\u0026lt; result[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; endl; return; } for (int i = 1; i \u0026lt;= N; ++i) { if (!used[i]) { result[k] = i; used[i] = 1; permutation1(k + 1); used[i] = 0; } } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%90%9C%E7%B4%A2/lake-counting/",
	"title": "Lake Counting",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ2386 Lake Counting\n题目描述 一个N*M的院子，雨后有积水。八连通的积水被认为是在一起的。求总共多少个水洼？\n解题思路  用dfs遍历院子，进行染色。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; char maze[110][110]; int visit[110][110]; int color; int n;//n行 int m;//m列 int go[8][2] = { {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {-1, -1},{0, -1}, {1, -1} }; void dfs(int x, int y); int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); int i, j; color = 0; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026quot;%s\u0026quot;, maze[i]); } for (i = 0; i \u0026lt; n; ++i) { for (j = 0; j \u0026lt; m; ++j) { if (!visit[i][j] \u0026amp;\u0026amp; maze[i][j] == 'W') { color++; dfs(i, j); } } } printf(\u0026quot;%d\\n\u0026quot;, color); return 0; } void dfs(int x, int y) { visit[x][y] = 1; int i; for (i = 0; i \u0026lt; 8; ++i) { int xx = x + go[i][0]; int yy = y + go[i][1]; if (xx \u0026gt;= 0 \u0026amp;\u0026amp; xx \u0026lt; n \u0026amp;\u0026amp; yy \u0026gt;= 0 \u0026amp;\u0026amp; yy \u0026lt; m \u0026amp;\u0026amp; maze[xx][yy] == 'W' \u0026amp;\u0026amp; !visit[xx][yy]) { dfs(xx, yy); } } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%90%9C%E7%B4%A2/",
	"title": "搜索",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%90%9C%E7%B4%A2/%E9%83%A8%E5%88%86%E5%92%8C%E9%97%AE%E9%A2%98/",
	"title": "部分和问题",
	"tags": [],
	"description": "",
	"content": "题目描述 给定n(n\u0026lt;20)个数，判断是否可以从中选出若干个数，使他们的和为k。\n解题思路  用dfs枚举可能的组合  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; const int MAXN = 30; int n;//n个数 int k; int a[MAXN]; bool dfs(int x, int sum); int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); int i; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); } scanf(\u0026quot;%d\u0026quot;, \u0026amp;k); bool ans; ans = dfs(0, 0); if (ans) { printf(\u0026quot;Yes\\n\u0026quot;); } else printf(\u0026quot;No\\n\u0026quot;); return 0; } bool dfs(int x, int sum) { if (x == n) { if (sum == k) return true; return false; } //不加上a[x] if (dfs(x + 1, sum)) return true; //加上a[x] if (dfs(x + 1, sum + a[x])) return true; return false; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/",
	"title": "并查集",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/",
	"title": "单调栈与单调队列",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
	"title": "动态规划",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%9D%82%E8%B0%88/",
	"title": "杂谈",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%9D%82%E8%B0%88/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%8F%98%E9%87%8F%E5%90%8D%E5%91%BD%E5%90%8D%E6%8C%87%E5%8D%97/",
	"title": "算法竞赛变量名命名指南",
	"tags": [],
	"description": "",
	"content": " 参考黄学长的博客 算法竞赛的代码的确和其它大作业、工程代码等不一样，时间紧任务重，所以一般命名都是缩写，只有当事人能看明白那种。 但是太简略了可能自己都搞蒙了。所以可参考以下命名方法：   add 加 anc, ancestor 祖先 ans, answer 答案 bel, belong 属于 best 最佳的 build 建立 block 障碍 ch, char 字符 check 判定 color 颜色 cmp, compare 比较 cnt, count 计数器 cur, current 当前量 deg, degree 度数 dep, depth 深度 del, delete 删除 delta 增量 diff, difference 差别 dist, distance 距离 div, division 除法，部分 dp 动态规划 edge 边 extra 额外的 fa, father 父亲 factor 因子 flag 标志 flow 流 from 来自 get 得到 Hash 哈希表（hash是保留字） heap 堆 in 入 ind, index 标号 inq 在队列里 inf, infinity 无穷大 init, initialize 初始化 insert 插入 inv, inverse 翻转，颠倒 last 最后一个 len, length 长度 lim, limit 极限 low, lower 下边的 mat, matrix 矩阵 mid, middle 中间量 mod 模 modify 修改 mp, map 映射 mst 最小生成树 mul, multiply 乘法 node 结点 num, number 数量 nxt 后继（next是保留字） out 出 pa, pair 对子 pre, precursor 前驱 prime 质数 pos, position 位置 prod, product 乘积 put 放置 que, queue 队列 query 询问 rank 秩 res, result 结果 res, residual 剩余 scc 强连通分量 size 大小 split 分裂 start 开始 stk, stack 栈 str 字符串 suc, succeed 后继 sum 和 tim 时间（time是保留字） tmp, temporary 临时量 tree 树 to 表目的 unite 联合 up, upper 上边的 update 更新 used 使用过的 val, value 值 vec, vector 向量 vis, visit 访问 zero 零 "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E4%BA%8C%E5%88%86/%E5%80%9F%E6%95%99%E5%AE%A4/",
	"title": "借教室",
	"tags": [],
	"description": "",
	"content": "题目链接 借教室\n题目描述  有n天，m个借教室的订单。每个订单有d,s,t三项，分别是租借的数量，租借开始、结束分别在第几天。 借教室按照先来后到的原则，但是可能到某个订单时，剩余教室不足，因此无法满足订单内容。 如果所有订单均可满足，则输出只有一行，包含一个整数0。否则输出两行，第一行输出一个负整数−1，第二行输出需要修改的订单编号。  解题思路  首先，此题中每个订单相当于对一个区间的内容整体加/减一个数，因此容易想到用差分。 本题巧妙地使用了二分答案的思想。对于能否二分，有一个界定标准：状态的决策过程或者序列是否满足单调性或者可以局部舍弃性。而在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。 因此，本题思路如下，二分枚举可能的答案d。每次都利用差分思想，计算为了满足从1到d的订单，每日所需的教室数量。然后根据实际的教室数量判断其能否满足。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int n, m;//天数和订单数量 int num[1000010];//num[i]表示第i天可租借教室数量 int need[1000010];//need[i]表示第i天需要的教室数量 int diff[10000100];//need的差分,从而快速计算出need[i] struct Order {//订单 int d, s, t; }; Order odr[1000010]; bool judgeOrder(int d); int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); int i = 0; for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;num[i]); } for (i = 1; i \u0026lt;= m; ++i) { scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;odr[i].d, \u0026amp;odr[i].s, \u0026amp;odr[i].t); } int left = 1; int right = m; int mid; int ans; ans = 0; //首先判断所有订单是否均能满足 if (judgeOrder(m)) { printf(\u0026quot;0\\n\u0026quot;); } else { while (left \u0026lt;= right) { mid = (left + right) / 2; if (judgeOrder(mid)) { left = mid + 1; } else { ans = mid; right = mid - 1; } } printf(\u0026quot;-1\\n%d\\n\u0026quot;, ans); } return 0; } bool judgeOrder(int d) { memset(diff, 0, sizeof(diff)); int i; //求差分 for (i = 1; i \u0026lt;= d; ++i) { diff[odr[i].s] += odr[i].d; diff[odr[i].t + 1] -= odr[i].d; } //利用差分计算出从第1个订单到第d个订单，每天需要的教室数量， //并进行判断 for (i = 1; i \u0026lt;= n; ++i) { need[i] = need[i - 1] + diff[i]; if (need[i] \u0026gt; num[i]) return false; } return true; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E4%BA%8C%E5%88%86/%E8%B7%B3%E7%9F%B3%E5%A4%B4/",
	"title": "跳石头",
	"tags": [],
	"description": "",
	"content": "题目链接 跳石头\n题目描述  已知起点到终点距离为L, 有N块岩石。组委会计划移走至多M块岩石，让选手的最短跳跃距离尽可能长。 求最短跳跃距离的最大值。  解题思路  一般求最短距离的最大值，或者最大距离的最小值，都用二分答案的方法。 注意此题中移走的M块岩石不包括起点和终点，在模拟时可将起点和终点的岩石加上。 注意二分答案的写法。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int L;//起点到终点的距离 int N;//石头数 int M;//组委会至多移动走的石头数 int a[50010];//a[i]表示第i个石头离起点的距离 bool judgeDis(int d); int main() { scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;L, \u0026amp;N, \u0026amp;M); int i; for (i = 1; i \u0026lt;= N; ++i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); } a[0] = 0; a[N + 1] = L; int left = 0; int right = L; int mid; int ans; while (left \u0026lt;= right) { mid = (left + right) / 2; if (judgeDis(mid)) { ans = mid; left = mid + 1; } else { right = mid -1 ; } } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } bool judgeDis(int d) { int now = 0;//人当前的位置 int tol = 0;//总共需要移动的岩石数 int i = 1; while (i \u0026lt;= N) { if (a[i] - a[now] \u0026lt; d) { i++; tol++; } else { now = i; i++; } } return (tol \u0026lt;= M); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E4%BA%8C%E5%88%86/",
	"title": "二分",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E5%8C%BA%E9%97%B4%E7%AD%9B%E6%B3%95/",
	"title": "区间筛法",
	"tags": [],
	"description": "",
	"content": "题目描述 求区间[a, b)内素数个数？其中a, b范围为1e12, b-a的范围是1e6\n解题思路  利用素数筛法。b以内的合数的最小质因数一定不超过sqrt(b)。因此在[2, sqrt(b))上筛素数的同时，也可将[a,b)中的合数筛去。 因为题中a,b较大，所以构建[a, b)的表需要映射成0~b-a。 题中的乘法需要long long范围，因此可将所有数都用long long范围。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; typedef long long ll; const long long MAXN = 1e6 + 10; bool is_prime[MAXN];//is_prime[i - a]判断i是否为素数，筛[a, b) bool is_prime_small[MAXN];//is_prime_small[i]判断i是否为素数,筛[2, sqrt(b)) /* 对区间[a, b)内的整数进行筛法 */ ll segment_sieve(ll a, ll b) { for(ll i = 0; i * i \u0026lt; b; ++i){ is_prime_small[i] = true; } for(ll i = 0, j = b - a; i \u0026lt; j; ++i){ is_prime[i] = true; } for(ll i = 2; i * i \u0026lt; b; ++i){ if(is_prime_small[i]){ //筛[2, sqrt(b)) for(ll j = 2*i; j * j \u0026lt; b; j += i){ is_prime_small[j] = false; } //筛[a, b) for(ll j = max((a + i - 1)/i, 2LL)*i; j \u0026lt; b; j += i){ is_prime[j - a] = false; } } } ll ans = 0; for(ll i = 0, j = b - a; i \u0026lt; j; ++i){ if(is_prime[i]) ans++; } return ans; } int main() { ll a, b; scanf(\u0026quot;%lld%lld\u0026quot;, \u0026amp;a, \u0026amp;b); ll ans = segment_sieve(a, b); printf(\u0026quot;%lld\\n\u0026quot;, ans); return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/carmichael-numbers/",
	"title": "Carmichael Numbers",
	"tags": [],
	"description": "",
	"content": "题目链接 Carmichael Numbers\n题目描述 如果对任意的 1 \u0026lt; x \u0026lt; n 都有 x^n≡x(mod n)成立的合数n称为Carmichael Numbers。给出一些整数n,请判断是否为Carmichael Numbers，其中2 \u0026lt; n \u0026lt; 65000\n解题思路  首先判断n是否为合数 利用快速幂计算x^n  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; typedef long long ll; /* 判断是否为质数 */ bool is_primer(int n) { for(int i = 2; i*i \u0026lt;= n; ++i){ if(n %i == 0) return false; } return true; } /* 快速幂 */ ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while(n \u0026gt; 0){ if(n \u0026amp; 1){ res = res * x % mod; } x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } int main() { ll n; bool flag = 1; ll ans; while(1){ flag = 1; scanf(\u0026quot;%lld\u0026quot;, \u0026amp;n); if(!n) break; //如果n是质数 if(is_primer((int)n)){ printf(\u0026quot;%lld is normal.\\n\u0026quot;, n); } else{ for(ll x = 2; x \u0026lt; n; ++x){ ans = mod_pow(x, n, n); if(ans != x){ flag = 0; break; } } if(flag) printf(\u0026quot;The number %lld is a Carmichael number.\\n\u0026quot;, n); else printf(\u0026quot;%lld is normal.\\n\u0026quot;, n); } } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E5%9F%83%E5%BC%8F%E7%AD%9B%E6%B3%95/",
	"title": "埃式筛法",
	"tags": [],
	"description": "",
	"content": "题目描述 给定数n，求n以内的素数个数\n解题思路  利用筛法求素数，首先假设3~n均为素数。由于对于一个数i，如果i是素数，则2i,3i\u0026hellip;\u0026hellip;均不是素数。利用此方法筛选后，剩下的就是素数  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; const int MAXN = 1000010; int prime[MAXN];//prime[i]为n的第i个素数 bool is_prime[MAXN]; /* 素数筛法，返回n以内的素数的个数 */ int sieve(int n) { int p = 0; int i, j; for(i = 0; i \u0026lt;= n; ++i){ is_prime[i] = true; } is_prime[0] = is_prime[1] = false; for(i = 2; i \u0026lt;= n; ++i){ if(is_prime[i]){ prime[++p] = i; for(j = 2*i; j \u0026lt;= n; j += i){ is_prime[j] = false; } } } return p; } int main() { int n; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); int ans = sieve(n); printf(\u0026quot;%d\\n\u0026quot;, ans); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A/",
	"title": "素数判定",
	"tags": [],
	"description": "",
	"content": "题目描述 给定数n，判断n是否为素数；求n的约数；求n的整数分解形式\n解题思路  枚举n可能的约数  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;map\u0026gt; using namespace std; /* 素数测试判断素数 */ bool isPrime1(int n) { if(n == 1) return false; int k = sqrt(n); for (int i = 2; i \u0026lt;= k; ++i){ if(n % i == 0) return false; } return true; } /* 约数枚举 */ vector\u0026lt;int\u0026gt; divisor(int n) { vector\u0026lt;int\u0026gt; res; int k = sqrt(n); for(int i = 1; i \u0026lt;= k; ++i){ if(n % i == 0){ res.push_back(i); if(i != n/i) res.push_back(n/i); } } return res; } /* 整数分解 */ map\u0026lt;int, int\u0026gt; prime_factor(int n){ map\u0026lt;int, int\u0026gt; res; //记录n的每个约数及该约数的个数 //由于整数分解时n是变的，因此用i*i \u0026lt;= n判断 for(int i = 2; i * i \u0026lt;= n; ++i){ while(n % i == 0){ ++res[i]; n /= i; } } if(n != 1) res[n] = 1; return res; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E5%8F%8C%E5%85%AD/",
	"title": "双六",
	"tags": [],
	"description": "",
	"content": "题目描述 一个双六上面有向前向后无线延续的格子，每个格子都写有整数。其中0号是起点，1号是终点。输入整数a和b，一个骰子只有a,b,-a,-b四个 整数。问抛出四个数多少次可到达终点？如果解不唯一，输出一组即可。如果无解，输出-1。\n解题思路  即求整数x,y使得ax+by=1。 有解条件为gcd(a, b)=1。 利用扩展的欧几里得算法可求解。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; /* 扩展欧几里得算法，在求gcd(a, b)的同时， 求出一对(x, y)满足a*x + b*y = gcd(a, b) */ int extgcd(int a, int b, int\u0026amp; x, int\u0026amp; y) { int d = a; if(b != 0){ d = extgcd(b, a%b, y, x); y -= (a/b) * x; } else{ x = 1; y = 0; } return d; } int main() { int a, b; int x, y; int n1, n2, n3, n4; // 对应a, b, -a, -b的个数 scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b); int d; d = extgcd(a, b, x, y); if(d != 1){ printf(\u0026quot;-1\\n\u0026quot;); } else{ n1 = n2 = n3 = n4 = 0; if(x \u0026gt; 0) n1 = x; else n3 = -x; if(y \u0026gt; 0) n2 = y; else n4 = -y; printf(\u0026quot;%d%d%d%d\\n\u0026quot;, n1, n2, n3, n4); } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E7%BA%BF%E6%AE%B5%E4%B8%8A%E7%9A%84%E6%A0%BC%E7%82%B9%E6%95%B0/",
	"title": "线段上的格点数",
	"tags": [],
	"description": "",
	"content": "题目描述 给定平面上的两个格点P和Q的坐标。求线段PQ除端点以外一共有多少个格点？\n解题思路  答案是线段x轴投影长度与y轴投影长度的最大公约数-1 注意特判P与Q重合的情况  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; /*辗转相除法，求a和b的最大公约数*/ int gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b); } int main() { int x1, y1, x2, y2; scanf(\u0026quot;%d%d%d%d\u0026quot;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); int dx = abs(x1 - x2); int dy = abs(y1 - y2); int ans; if(!dx \u0026amp;\u0026amp; !dy){ //特判dx==0\u0026amp;\u0026amp;dy==0的情况 ans = 0; } else{ ans = gcd(dx, dy) - 1; } printf(\u0026quot;%d\\n\u0026quot;, ans); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/",
	"title": "数论",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E7%BA%BF%E6%AE%B5%E6%A0%91/%E5%8C%BA%E9%97%B4%E6%8A%91%E6%88%96/",
	"title": "ZGOJ1561 区间抑或",
	"tags": [],
	"description": "",
	"content": "题目链接 打不开了\n题目描述  忘了  解题思路  利用线段树，区间操作注意用延迟更新，包括向下更新和向上更新。 注意要用unsigned int。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int a[100010]; unsigned int b; int n;//n个数 int m;//m个查询 struct Node { int L, R; int sum;//区间的抑或和 int lazy; int val; int Mid() { return (L + R) / 2; } }; Node tree[400010]; void build_tree(int root, int l, int r) { tree[root].L = l; tree[root].R = r; tree[root].lazy = 0; tree[root].val = 0; if (l == r) { tree[root].sum = a[l]; tree[root].val = a[l]; return; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); build_tree(lc, l, mid); build_tree(rc, mid + 1, r); tree[root].sum = tree[lc].sum ^ tree[rc].sum; } int query_tree(int root, int l, int r) { if (tree[root].L \u0026lt;= l \u0026amp;\u0026amp; tree[root].R \u0026gt;= r \u0026amp;\u0026amp; tree[root].lazy) { if ((r - l +1) % 2) { return tree[root].val; } else { return 0; } } if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { return tree[root].sum; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); if (r \u0026lt;= mid) { return query_tree(lc, l, r); } else if (l \u0026gt; mid) { return query_tree(rc, l, r); } else { return (query_tree(lc, l, mid) ^ query_tree(rc, mid + 1, r)); } } void change_tree(int root, int l, int r, int num) { if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { tree[root].val = num; tree[root].lazy = 1; if ((r - l +1 ) % 2) { tree[root].sum = num; } else tree[root].sum = 0; return; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); if (tree[root].lazy) { tree[root].lazy = 0; tree[lc].lazy = tree[rc].lazy = 1; tree[lc].val = tree[rc].val = tree[root].val; if ((tree[lc].R - tree[lc].L + 1) % 2) { tree[lc].sum = tree[lc].val; } else tree[lc].sum = 0; if ((tree[rc].R - tree[rc].L + 1) % 2) { tree[rc].sum = tree[rc].val; } else tree[rc].sum = 0; } if (r \u0026lt;= mid) { change_tree(lc, l, r, num); } else if (l \u0026gt; mid) { change_tree(rc, l, r, num); } else { change_tree(lc, l, mid, num); change_tree(rc, mid + 1, r, num); } tree[root].sum = tree[lc].sum ^ tree[rc].sum; //tree[root].lazy = 0; return; } int main() { int T; scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); int i, j; unsigned int ans;//注意要用unsigned int !!! while (T--) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); memset(tree, 0, sizeof(tree)); memset(a, 0, sizeof(a)); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%u\u0026quot;, \u0026amp;b); a[i] = (int)b; } build_tree(1, 1, n); char s[3]; int a, b, x; for (i = 1; i \u0026lt;= m; ++i) { scanf(\u0026quot;%s\u0026quot;, s); if (s[0] == 'C') { scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;x); change_tree(1, a, b, x); } else { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b); ans = query_tree(1, a, b); printf(\u0026quot;%u\\n\u0026quot;, ans); } } printf(\u0026quot;\\n\u0026quot;); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/",
	"title": "HomePage",
	"tags": [],
	"description": "",
	"content": "欢迎来到ZJQ的博客  本博客是基于hugo框架搭建的静态博客。本人第一次搭博客，动态博客也写不来，而且也设计不出这些主题。 博客内容以学习为主，经初步构思，本博客主要用来记录算法、计算机知识、电脑使用知识等。 佛系更新，更新快说明在认真学习ing，更新慢说明在摸鱼\u0026hellip;\u0026hellip; 祝大家开心快乐，学习进步！  "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E7%BA%BF%E6%AE%B5%E6%A0%91/majors_poster/",
	"title": "POJ2528 Mayor&#39;s poster",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ2528 Mayor\u0026rsquo;s poster\n题目描述  用多张海报贴一面墙，求贴完后有几张海报是可见的（完全可见+部分可见）。 题目有多组数据。 对于每组数据有n个海报，每个海报给定左、右端点，并按照贴的顺序给出。  解题思路  利用线段树，注意处理顺序是由外层到内层。因为外层覆盖的区间会影响内层的可见情况，而内层覆盖的区间不会影响外层的可见情况。 注意延迟更新  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; struct Node { int L, R; bool covered; int Mid() { return L + (R - L) / 2; } }; struct Line { int s, e; }; Line poster[10010];//记录海报 int disc[40010];//用于离散化 Node tree[160010];//线段树 int point[40010];//记录海报的两个端点，用于离散化 int point_num;//记录去重后的端点个数 void build_tree(int root, int l, int r); bool query_tree(int root, int l, int r); int main() { int c; int n;//c个样例，n个海报 scanf(\u0026quot;%d\u0026quot;, \u0026amp;c); int ans; int i, j; while (c--) { ans = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;poster[i].s, \u0026amp;poster[i].e); point[2 * i] = poster[i].s; point[2 * i + 1] = poster[i].e; } sort(point, point + 2 * n); point_num = unique(point, point + 2 * n) - point; int dcnt = 0; disc[dcnt] = point[0]; dcnt++; //离散化，要把两个端点中间的区间也离散化成一个区间， //因此如果(point[i]-point[i-1]\u0026gt;1)，就把point[i-1]+1当一个新区间 for(i = 1; i \u0026lt; point_num; ++i){ if( (point[i] - point[i-1]) \u0026gt; 1){ disc[dcnt] = point[i-1]+1;\tdcnt++; } disc[dcnt] = point[i]; dcnt++; } build_tree(1, 1, dcnt); int nl, nr; for(i = n - 1; i \u0026gt;= 0; --i){ nl = lower_bound(disc, disc + dcnt, poster[i].s) - disc + 1; nr = lower_bound(disc, disc + dcnt, poster[i].e) - disc + 1; if(!query_tree(1, nl, nr) ){ ans++; } } printf(\u0026quot;%d\\n\u0026quot;, ans); } } void build_tree(int root, int l, int r) { tree[root].L = l; tree[root].R = r; tree[root].covered = 0; if (l == r) return; int mid = tree[root].Mid(); build_tree((root \u0026lt;\u0026lt; 1), l, mid); build_tree((root \u0026lt;\u0026lt; 1) | 1, mid + 1, r); return; } bool query_tree(int root, int l, int r) { bool flag = 0; if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { flag = tree[root].covered; tree[root].covered = 1; return flag; } if(tree[root].L \u0026lt;= l \u0026amp;\u0026amp; tree[root].R \u0026gt;= r \u0026amp;\u0026amp; tree[root].covered){ //如果当前区间包裹了要查询的区间，且已经被覆盖了，就直接返回true, //因为你第一个是延迟更新，你这里不判断，就跑到下面了 //注意这里，错了两次了！！！ return 1; } int mid = tree[root].Mid(); int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; if (r \u0026lt;= mid) { flag = query_tree(lc, l, r); } else if (l \u0026gt; mid) { flag = query_tree(rc, l, r); } else { flag = query_tree(lc, l, mid) \u0026amp; query_tree(rc, mid + 1, r); } //注意更新cover的状态 tree[root].covered = tree[lc].covered \u0026amp; tree[rc].covered; return flag; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E7%BA%BF%E6%AE%B5%E6%A0%91/",
	"title": "线段树",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/",
	"title": "算法",
	"tags": [],
	"description": "",
	"content": "简介  本栏目期望能够长期更新，用于记录算法和数据结构。 主要内容是做过的题和代码。 由于本人从大学才开始接触算法，并且在学校被虐的死去活来QAQS，因此题目多为模板题。  "
},
{
	"uri": "https://zhujiaqi9905.github.io/machine_learning/",
	"title": "机器学习",
	"tags": [],
	"description": "",
	"content": "简介  以记录机器学习的代码实现为主 更新时间未知，因为偶还没开始学\u0026hellip;\u0026hellip;  "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/a-bugs-life/",
	"title": "A Bug&#39;s Life",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ2492 A Bug\u0026rsquo;s Life\n题目描述  有两种性别的虫子。它们只能不同性别间交配。给出一堆虫子的交配列表。判断是否满足只能在不同性别间交配的命题。  解题思路  利用带权并查集，把可以判断出性别关系的虫子放到同一集合中。 在Merge()和GetRoot()函数中更新子结点与根节点的性别关系。 性别关系类似于向量加减，可通过画向量图的方式计算结点间的关系。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; using namespace std; const int MAXN = 2010; int par[MAXN];//par[i]是i的根节点 int rea[MAXN];//rea[i]是i和根节点的关系,0是同性，1是异性 int GetRoot(int a, int r); void Merge(int a, int b, int r); bool Query(int a, int b); int n, m;//n个虫子，m个操作 int main() { int k; scanf(\u0026quot;%d\u0026quot;, \u0026amp;k); int kase = 0; while(k--){ ++kase; int i, r, x, y; bool flag = 0; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); for(i = 0;i \u0026lt;= n; ++i){ par[i] = i; rea[i] = 0; } for(i = 0;i \u0026lt; m; ++i){ scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y); if(!Query(x, y)){ Merge(x, y, 1); } else{ if(rea[x] == rea[y]){ flag = 1; } } } printf(\u0026quot;Scenario #%d:\\n\u0026quot;, kase); if(flag) printf(\u0026quot;Suspicious bugs found!\\n\u0026quot;); else printf(\u0026quot;No suspicious bugs found!\\n\u0026quot;); printf(\u0026quot;\\n\u0026quot;); } } int GetRoot(int a) { if(par[a] == a) return a; int pa = GetRoot(par[a]); rea[a] = (rea[par[a]] + rea[a])%2; par[a] = pa; return pa; } void Merge(int a, int b, int r) { int pa = GetRoot(a); int pb = GetRoot(b); if(pa != pb){ par[pb] = pa; rea[pb] = (rea[a] - r - rea[b] + 4) % 2; } return ; } bool Query(int a, int b) { return GetRoot(a) == GetRoot(b); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/cube-stacking/",
	"title": "Cube stacking",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ1988 Cube stacking\n题目描述  有N堆方块，开始每堆都是一个方块，编号为1~N。有两种操作： M x y: 表示把方块x所在的堆，拿起来叠放到y所在的堆上。 C x：问方块x下面有多少个方块。 操作最多P次。对每次C操作，输出结果。  解题思路  利用并查集。维护sum[]，记录每堆总共的方块数。维护under[],under[i]表示第i个方块下面的方块数。 sum在堆合并的时候更新，under在堆合并和路径压缩的时候更新。 这题相当于：落在上面的方块，在并查集树中是下面的叶子节点。把y所在的堆落到x所在的堆上，相当于y所在的树挂接到x所在的树上。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; //把最下面的块当树根 //把a摞到b上，相当于把a挂接到b上 //记录sum是为了更新under int N; int par[30010];//par[i]表示i的父节点 int sum[30010];//sum[i]表示第i堆总共的方块数 int under[30010];//under[i]表示在i下面的方块数 int Getroot(int x) { if(x == par[x]) return x; int px = Getroot(par[x]); under[x] += under[par[x]]; par[x] = px; return px; } void Merge(int x, int y)//把y所在的堆叠放到x所在的堆上 { int px = Getroot(x); int py = Getroot(y); if(px == py) return; par[py] = px; under[py] = sum[px]; sum[px] += sum[py]; } int main() { int i; for( i = 1; i \u0026lt;= 30000; ++i){ par[i] = i; sum[i] = 1; under[i] = 0; } int P; scanf(\u0026quot;%d\u0026quot;, \u0026amp;P); char s[20]; int a, b; for(int i = 0; i \u0026lt; P; ++i){ scanf(\u0026quot;%s\u0026quot;, s); if(s[0] == 'M'){ scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b); Merge(b,a); } else{ scanf(\u0026quot;%d\u0026quot;, \u0026amp;a); Getroot(a); printf(\u0026quot;%d\\n\u0026quot;, under[a]); } } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/the-suspects/",
	"title": "The Suspect",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ1611 The Suspect\n题目描述  有n个学生，编号0~n-1，m个团体，一个学生可以属于多个团体，或不属于任何团体。一个学生疑似患病，则整个团体疑似患病。 已知0号学生疑似患病，以及每个团体的学生构成情况，求一共有多少学生疑似患病。  解题思路  并查集模板题。维护sum[a]是a所在的集合的人数 注意最后求人数时，需要进行一遍路径压缩，来得到最新的sum[a]  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int par[30010]; int sum[30010];//sum[a]是a所在的集合的人数 int n;//n个学生 int m;//m个团体 int GetRoot(int x) { if(x == par[x]) return x; int px = GetRoot(par[x]); sum[x] = sum[px];//注意这里，从根往下更新 return px; } void Merge(int a, int b) { int ra= GetRoot(a); int rb = GetRoot(b); if(ra == rb) return; par[rb] = ra; sum[ra] += sum[rb]; return; } int main() { int i, j;int k; int a; int b; while(scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m)){ if(n==0 \u0026amp;\u0026amp; m == 0) break; for(i = 0; i \u0026lt;= n; ++i){ sum[i] = 1; par[i] = i; } for(i = 0; i \u0026lt; m; ++i){ scanf(\u0026quot;%d\u0026quot;, \u0026amp;k); scanf(\u0026quot;%d\u0026quot;, \u0026amp;a);//每个团体有k个人，先拿出一个，其它的人和他Merge for(j = 1; j \u0026lt; k ;++j){ scanf(\u0026quot;%d\u0026quot;, \u0026amp;b); Merge(a, b); } } GetRoot(0); printf(\u0026quot;%d\\n\u0026quot;, sum[0]); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E4%BF%AE%E5%A4%8D%E5%85%AC%E8%B7%AF/",
	"title": "修复公路",
	"tags": [],
	"description": "",
	"content": "题目链接 洛谷 修复公路\n题目描述  给出A地区的村庄数N，和公路数M，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。 问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）  解题思路  将修复公路的操作按照时间排序。维护记录集合中元素数目的并查集。 sum[GetRoot(a)]表示a所在的集合的元素个数，如果元素个数等于总村庄数，则全部连通。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstdlib\u0026gt; using namespace std; const int MAX = 1000; int parent[MAX + 10]; int sum[MAX + 10]; struct Part { int x, y, t; }; Part path[100010]; int myCompare(const void* e1, const void* e2); void Merge(int a, int b); int GetRoot(int a); bool Query(int a, int b); int main() { int N, M; //N村庄，M公路 scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;N, \u0026amp;M); int T = -1; for (int i = 0; i \u0026lt; M; ++i) { scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;path[i].x, \u0026amp;path[i].y, \u0026amp;path[i].t); } bool flag = 0; qsort(path, M, sizeof(Part), myCompare);//按时间从小到大排序 for (int i = 0; i \u0026lt;= N; ++i) { parent[i] = i; sum[i] = 1; } for (int i = 0; i \u0026lt; M; ++i) { if (!Query(path[i].x, path[i].y)) { Merge(path[i].x, path[i].y); if (sum[GetRoot(path[i].x)] == N) { T=path[i].t; break; } } } printf(\u0026quot;%d\\n\u0026quot;, T); } int myCompare(const void* e1, const void* e2) { const Part* p1 = (const Part*)e1; const Part* p2 = (const Part*)e2; if (p1-\u0026gt;t \u0026lt; p2-\u0026gt;t) return -1; else return 1; } int GetRoot(int a) { if (a != parent[a]) { parent[a] = GetRoot(parent[a]); } return parent[a]; } void Merge(int a, int b) { int rb = GetRoot(b); int ra = GetRoot(a); parent[rb] = ra; sum[ra] += sum[rb]; //根节点维护这个集合元素的总个数 return; } bool Query(int a, int b) { return GetRoot(a) == GetRoot(b); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/",
	"title": "导弹拦截",
	"tags": [],
	"description": "",
	"content": "题目链接 导弹拦截\n题目描述  求最长不上升子序列长度和最长上升子序列长度  解题思路  以最长上升子序列为例，传统方法是O(n^2)的，但是可以优化成O(nlog(n))。 首先，做法是两重循环，第一重循环枚举x，这个复杂度无法省掉。第二重循环是找出在x之前，a值大于a[x]的最大dp值。 第二重循环可以通过二分枚举dp值来实现。 需要维护一个数组r[],r[i]是在已经走过的这些元素中，长度为i的LIS最小以什么数结尾。那么，满足r[mid]\u0026lt;a[x]的mid值，都是候选解。 利用二分枚举求出其中最大的即可。 需要维护数组r[],在求出dp[x]之后，把r[dp[x]]设成min(r[dp[x]],a[x])即可。 可以使用upper_bound()函数，但是这里为了训练手写二分枚举，就没用板子。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int a[100010];//导弹的高度 int dp1[100010];//dp1[i]是从第1~第i个以第i结尾的最长不上升子序列长度。 int r1[100010];//在已经走过的这些元素中，长度为i的最长不上升子序列长度最大以什么数结尾。 int dp2[100010];//dp2[i]是从第1~第i个以第i结尾的最长上升子序列长度。 int r2[100010];//在已经走过的这些元素中，长度为i的LIS最小以什么数结尾。 int n; void bin_check1(int x); void bin_check2(int x); int main() { int i, j; n = 1; while (scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[n]) != EOF) { n++; } n--; dp1[1] = 1; r1[1] = a[1]; for (i = 2; i \u0026lt;= n; ++i) { bin_check1(i); } int ans1 = 0; for (i = 1; i \u0026lt;= n; ++i) { ans1 = max(ans1, dp1[i]); } dp2[1] = 1; r2[1] = a[1]; for (i = 2; i \u0026lt;= n; ++i) { bin_check2(i); } int ans2 = 0; for (i = 1; i \u0026lt;= n; ++i) { ans2 = max(ans2, dp2[i]); } printf(\u0026quot;%d\\n\u0026quot;, ans1); printf(\u0026quot;%d\\n\u0026quot;, ans2); return 0; } /* 二分猜测答案 */ void bin_check1(int x) { int left = 1; int right = x - 1; int ans = 0; int mid; //二分枚举dp1[x]的可能解 while (left \u0026lt;= right) { //猜测一个dp1值为mid mid = (left + right) / 2; if (r1[mid] != 0 \u0026amp;\u0026amp; r1[mid] \u0026gt;= a[x]) { ans = mid; left = mid + 1; } else { right = mid - 1; } } dp1[x] = ans + 1; //维护r1数组，特殊处理等于0的情况。 if (r1[dp1[x]] == 0) { r1[dp1[x]] = a[x]; } else { r1[dp1[x]] = max(r1[dp1[x]], a[x]); } return; } /* 二分猜测答案 */ void bin_check2(int x) { int left = 1; int right = x - 1; int ans = 0; int mid; //二分枚举dp2[x]的可能解 while (left \u0026lt;= right) { //猜测一个dp2值为mid mid = (left + right) / 2; if (r2[mid] != 0 \u0026amp;\u0026amp; r2[mid] \u0026lt; a[x]) { ans = mid; left = mid + 1; } else { right = mid - 1; } } dp2[x] = ans + 1; //维护r2数组，特殊处理等于0的情况。 if (r2[dp2[x]] == 0) { r2[dp2[x]] = a[x]; } else { r2[dp2[x]] = min(r2[dp2[x]], a[x]); } return; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/",
	"title": "最长公共子序列",
	"tags": [],
	"description": "",
	"content": "题目链接 最长公共子序列\n题目描述  给出1-n的两个排列P1和P2，求它们的最长公共子序列长度  解题思路  此题用一般的求最长公共子序列长度的算法是O(n^2)的，会超时。应该用O(nlog(n))的算法。 本题中P1和P2是两个排列，因此序列中没有重复元素，可以考虑一个神转化。 首先，将P1的序列重新编号。例如\u0026quot;32145\u0026quot;中，3对应1、2对应2、1对应3、4对应4、5对应5。然后用新编号改变P2,例如\u0026quot;12345\u0026quot;改变成\u0026quot;32145\u0026rdquo;。 此时，P2串里面每一个上升的子序列，都唯一对应P1串一个子序列。 求P2串最长上升子序列有O(nlog(n))的算法。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int a[100010];//存储p1串 int b[100010];//读入p2串，并按新编号转化 int mapp[100010];//重新编号，mapp[a[i]]=i int n; int dp[100010];//dp[i]是从第1~第i个以第i结尾的最长上升子序列长度。 int r[100010];//在已经走过的这些元素中，长度为i的LIS最小以什么数结尾。 void bin_check(int x); int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); int i; for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); mapp[a[i]] = i;//新的对应 } for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;b[i]); b[i] = mapp[b[i]];//用新的对应，转化P2串 } dp[1] = 1; r[1] = b[1]; for (i = 2; i \u0026lt;= n; ++i) { bin_check(i); } int ans = 0; for (i = 1; i \u0026lt;= n; ++i) { ans = max(ans, dp[i]); } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } void bin_check(int x) { int left = 1; int right = x - 1; int mid = 0; int ans = 0; while (left \u0026lt;= right) { mid = (left + right) / 2; if (r[mid] != 0 \u0026amp;\u0026amp; r[mid] \u0026lt; b[x]) { ans = mid; left = mid + 1; } else { right = mid - 1; } } dp[x] = ans + 1; if (r[dp[x]] == 0) { r[dp[x]] = b[x]; } else { r[dp[x]] = min(r[dp[x]], b[x]); } return; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/%E8%9A%AF%E8%9A%93/",
	"title": "蚯蚓",
	"tags": [],
	"description": "",
	"content": "题目链接 蚯蚓\n题目描述  见链接。  解题思路  如果直接用优先队列会超时。 首先考虑：没有被切过的蚯蚓，只要开始时按从大到小排序，那么今后的任意时刻，因为每次增加长度相同，所以一定是排在前面的先被切。 被切过的蚯蚓分成两部分，较长的和较短的。对于较长的，先被切的一定比后被切的长。对于较短的，也如此。 可以维护三个队列，队列1表示最开始的蚯蚓，队列2表示每一次被切的蚯蚓被分开的较长的那一部分，队列3表示每一次被切的蚯蚓被分开的较短的那一部分。 因为队列1的元素是按时间顺序出队，队列2、3的元素是按时间顺序入队，所以对于增量的计算我们可以按照蚯蚓在队列中的标号。 代码书写时，三个队列可用队列数组表示，这样有利于用循环进行枚举。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; const int MAXN = 1e7; int n, m, q, T; double u, v, p; //三个队列 int que[4][MAXN]; //每个队列的头尾坐标 int head[4]; int tail[4]; int length[MAXN];//length[i]记录i时刻被切的蚯蚓长度，在输出答案时用 int finLength[MAXN];//finLength[i]记录m秒后，排序后的蚯蚓长度，在输出答案时用 int getLength(int t); void printAns(); int main() { scanf(\u0026quot;%d%d%d%lf%lf%d\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;q, \u0026amp;u, \u0026amp;v, \u0026amp;T); p = u / v; int i, j; for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;que[1][i]); } head[1] = head[2] = head[3] = 1; tail[1] = n + 1; tail[2] = tail[3] = 1; sort(que[1] + head[1], que[1] + tail[1], greater\u0026lt;int\u0026gt;()); int x; int lb, lc; for (i = 1; i \u0026lt;= m; ++i) { x = getLength(i); lb = (int)floor(x * p); lc = x - lb; if (lb \u0026lt; lc) swap(lb, lc); que[2][tail[2]++] = lb; que[3][tail[3]++] = lc; } printAns(); return 0; } int getLength(int t) { int num = 0; int sum = 0; for (int i = 1; i \u0026lt;= 3; ++i) { if (head[i] \u0026lt; tail[i] \u0026amp;\u0026amp; i == 1 \u0026amp;\u0026amp; (que[i][head[i]] + (t - 1) * q \u0026gt; sum)) { sum = que[i][head[i]] + (t - 1)* q; num = i; } else if (head[i]\u0026lt;tail[i] \u0026amp;\u0026amp; ( (que[i][head[i]] + (t - 1 - head[i]) * q) \u0026gt; sum) ) { sum = que[i][head[i]] + (t - 1 - head[i]) * q; num = i; } } length[t] = sum; head[num]++; return sum; } void printAns() { int i, j; for (i = 1; i \u0026lt;= m / T; ++i) { printf(\u0026quot;%d \u0026quot;, length[i * T]); } printf(\u0026quot;\\n\u0026quot;); int num = 0; for (i = 1; i \u0026lt;= 3; ++i) { for (j = head[i]; j \u0026lt; tail[i]; ++j) { if (i == 1) { finLength[++num] = que[i][j] + m * q; } else { finLength[++num] = que[i][j] + (m - j) * q; } } } sort(finLength + 1, finLength + 1 + num, greater\u0026lt;int\u0026gt;()); for (i = 1; i \u0026lt;= (n + m) / T; ++i) { printf(\u0026quot;%d \u0026quot;, finLength[T * i]); } printf(\u0026quot;\\n\u0026quot;); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/",
	"title": "装箱问题",
	"tags": [],
	"description": "",
	"content": "题目链接 装箱问题\n题目描述  有一个箱子容量为V，同时有n个物品，每个物品有一个体积（正整数）。要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。  解题思路  可转化为01背包问题。即求如何装，使箱子占有空间最大，总空间减去最大占有空间，即为最小剩余空间。此题可看成物品的价值等于物品体积。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int w[40];//存体积，也相当于价值 int dp[20010];//滚动数组，dp[i][j]计算前i个物品，体积j的背包，装的最大占有空间。其中i被省略。 int V;//容量 int n;//n个物品 int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;V); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); int i; int j; for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;w[i]); } for (i = w[1]; i \u0026lt;= V; ++i) { dp[i] = w[1]; } //滚动数组dp for (i = 2; i \u0026lt;= n; ++i) { for (j = V; j \u0026gt;= w[i]; --j) { dp[j] = max(dp[j], dp[j - w[i]] + w[i]); } } int ans = 0; for (i = 1; i \u0026lt;= V; ++i) { ans = max(dp[i], ans); } ans = V - ans; printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%87%87%E8%8D%AF/",
	"title": "采药",
	"tags": [],
	"description": "",
	"content": "题目链接 采药\n题目描述  山洞里有药，每种药有一定价值，和需要的采药时间。已知：T代表总共能够用来采药的时间，M代表山洞里的草药的数目，求最多能采药的价值？  解题思路  标准的01背包问题。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int T;//采药时间 int M;//草药数目 int wgh[110]; int val[110]; int dp[1010]; int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;T, \u0026amp;M); int i, j; for (i = 1; i \u0026lt;= M; ++i) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;wgh[i], \u0026amp;val[i]); } for (i = wgh[1]; i \u0026lt;= T; ++i) { dp[i] = val[1]; } for (i = 2; i \u0026lt;= M; ++i) { for (j = T; j \u0026gt;= wgh[i]; --j) { dp[j] = max(dp[j], dp[j - wgh[i]] + val[i]); } } int ans = 0; for (i = 1; i \u0026lt;= T; ++i) { ans = max(ans, dp[i]); } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4/",
	"title": "银河英雄传说",
	"tags": [],
	"description": "",
	"content": "题目链接 洛谷 银河英雄传说\n题目描述  见链接。实际上和Cube stacking类似。  解题思路  类似于Cube stacking。利用并查集，维护sum[]数组和under[]数组。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; const int MAX = 30000; int parent[MAX + 10];//parent[i]是i的父节点 int sum[MAX + 10];//sum[i]是以i为根的集合的元素个数 int under[MAX + 10];//under[i]是i下面有的个数 int GetRoot(int a); void Merge(int a, int b); bool Query(int a, int b); int main() { for (int i = 1; i \u0026lt;= MAX; ++i) { parent[i] = i; sum[i] = 1; under[i] = 0; } int T = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); char c[2]; int x; int y; while (T--) { scanf(\u0026quot;%s%d%d\u0026quot;, c, \u0026amp;x, \u0026amp;y); if (c[0] == 'M') { Merge(x, y); } else { if (Query(x, y)) { printf(\u0026quot;%d\\n\u0026quot;, abs(under[x] - under[y]) - 1); } else { printf(\u0026quot;-1\\n\u0026quot;); } } } return 0; } int GetRoot(int a) { if (a == parent[a]) return a; int ra = GetRoot(parent[a]); under[a] += under[parent[a]]; parent[a] = ra; return ra; } void Merge(int a, int b)//把a放到b上 { int ra = GetRoot(a); int rb = GetRoot(b); parent[ra] = rb; under[ra] = sum[rb]; sum[rb] += sum[ra]; return; } bool Query(int a, int b) { return GetRoot(a) == GetRoot(b); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E9%A3%9F%E7%89%A9%E9%93%BE/",
	"title": "食物链",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ1182 食物链\n题目描述  动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这N个动物所构成的食物链关系进行描述： 第一种说法是\u0026quot;1 X Y\u0026rdquo;，表示X和Y是同类。 第二种说法是\u0026quot;2 X Y\u0026rdquo;，表示X吃Y。 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。  1） 当前的话与前面的某些真的话冲突，就是假话； 2） 当前的话中X或Y比N大，就是假话； 3） 当前的话表示X吃X，就是假话。   你的任务是根据给定的N（1 \u0026lt;= N \u0026lt;= 50,000）和K句话（0 \u0026lt;= K \u0026lt;= 100,000），输出假话的总数。  解题思路  利用带权并查集，把\u0026quot;可以判断出捕食关系的动物\u0026quot;放到同一集合中。 在Merge()和GetRoot()函数中更新子结点与根节点的捕食关系。 捕食关系类似于向量加减，可通过画向量图的方式计算结点间的关系。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; using namespace std; const int MAXN = 50010; int parent[MAXN]; int relation[MAXN];//x吃y是1，x被y吃是2，x与y是同类是0 //把x与y的关系，看成是x指向y的向量，用向量的运算做 int n;//n个动物 void Merge(int a, int b, int r); int GetRoot(int x); bool Query(int a, int b); int main() { int i, j; int k; int sum = 0; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;k); int r, x, y; for(i = 1; i \u0026lt;= n; ++i){ parent[i] = i; } for(i = 0; i \u0026lt; k; ++i){ scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;r, \u0026amp;x, \u0026amp;y); if(x \u0026gt; n || y \u0026gt; n){ sum++;\t} else if(x == y \u0026amp;\u0026amp; r == 2){ //注意，题目中的r和我们定义的relation不同，一定要审题+仔细 sum++; } else{ if(!Query(x, y)){ Merge(x, y, r - 1);\t} else{ if((relation[x] - relation[y] + 3)%3 != (r - 1)){ sum++; } } } } printf(\u0026quot;%d\\n\u0026quot;, sum); } int GetRoot(int x) { if(x == parent[x]) return x; int px = GetRoot(parent[x]); relation[x] = (relation[parent[x]] + relation[x])%3; parent[x] = px; return px; } void Merge(int a, int b, int r) { int pa = GetRoot(a); int pb = GetRoot(b); if(pa != pb){ //注意这里，如果相同就不能更新关系 //其实每次Merge()前会判断是否在同一棵树上，但是加上更保险 parent[pb] = pa; relation[pb] = (relation[a] - (relation[b] + r) + 6)%3; } return ; } bool Query(int a, int b) { return GetRoot(a) == GetRoot(b); } "
}]
[
{
	"uri": "https://zhujiaqi9905.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/",
	"title": "决策树",
	"tags": [],
	"description": "",
	"content": "简述  决策树是一种类似于规则学习的机器学习方法。决策树的每个结点代表一个属性，分支代表该属性的取值。 构造时通过计算每个特征的信息增益，来找到当前最好的用于分类的特征。 决策树在python中是一个多层嵌套的字典，利用递归的方式生成 两大块代码，一块用于建树，一块用于画出树的图。 建树的代码中，感觉把树存到文件的代码有点问题，以后会改正。因为我对matplotlib不熟，所以画图代码还需要改进。  代码  建树部分  from math import log import operator import pickle def calShannonEnt(dataSet): \u0026#39;\u0026#39;\u0026#39;计算集合的香侬熵\u0026#39;\u0026#39;\u0026#39; numEntries = len(dataSet) labelCounts = {} #记录每种标签的个数 for featVec in dataSet: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 1 else: labelCounts[currentLabel] += 1 shannonEnt = 0.0 for key in labelCounts: prob = float(labelCounts[key]) / numEntries shannonEnt += -prob * log(prob, 2) return shannonEnt def splitDataSet(dataSet, axis, value): \u0026#39;\u0026#39;\u0026#39;按照给定特征划分数据集axis 特征, value 特征的取值\u0026#39;\u0026#39;\u0026#39; retDataSet = [] for featVec in dataSet: if featVec[axis] == value: #把数据集中axis的特征抽走 reducedFeatVec = featVec[ : axis] reducedFeatVec.extend(featVec[axis+1 :]) #注意这是extend #样本加入新的集合 retDataSet.append(reducedFeatVec) return retDataSet def chooseBestFeatureToSplit(dataSet): \u0026#39;\u0026#39;\u0026#39;选取最好的数据集划分方式\u0026#39;\u0026#39;\u0026#39; numFeatures = len(dataSet[0]) - 1 baseEntropy = calShannonEnt(dataSet) bestInfoGain = 0.0 bestFeature = -1 for i in range(numFeatures): #找出特征i的所有值 featList = [example[i] for example in dataSet] uniqueVals = set(featList) newEntropy = 0.0 for value in uniqueVals: #划分数据集 subDataSet = splitDataSet(dataSet, i, value) #计算划分后引起的熵变化 prob = len(subDataSet) / float(len(dataSet)) newEntropy += prob * calShannonEnt(subDataSet) #计算信息增益 infoGain = baseEntropy - newEntropy if infoGain \u0026gt; bestInfoGain: bestInfoGain = infoGain bestFeature = i return bestFeature def majorityCnt(classList): \u0026#39;\u0026#39;\u0026#39;计算某一特征中出现频率最高的取值,classList 样本中某个特征的取值列表\u0026#39;\u0026#39;\u0026#39; classCount = {} for vote in classList: if vote not in classCount.keys(): classCount[vote] = 1 else: classCount[vote] += 1 #按出现频率从高到低排序 #classCount.items()返回一个可遍历的(键, 值) 元组数组 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] def createTree(dataSet, labels): \u0026#39;\u0026#39;\u0026#39;构造决策树，返回值是类别标签\u0026#39;\u0026#39;\u0026#39; classList = [example[-1] for example in dataSet] #如果数据集中全是相同标签的样本，则停止划分 if classList.count(classList[0]) == len(classList): return classList[0] #如果使用完所有特征，仍不能划分完全，就返回出现次数最多的类别 if len(dataSet[0]) == 1: return majorityCnt(classList) #找到当前最好的划分特征 bestFeat = chooseBestFeatureToSplit(dataSet) bestFeatLabel = labels[bestFeat] #树的结构是一个多层嵌套的字典  myTree = {bestFeatLabel:{}} del(labels[bestFeat]) #得到该属性的所有属性值 featValues = [example[bestFeat] for example in dataSet] uniqueVals = set(featValues) for value in uniqueVals: subLabels = labels[:] #复制标签 myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels) return myTree def classify(inputTree, featLabels, testVec): \u0026#39;\u0026#39;\u0026#39;分类器\u0026#39;\u0026#39;\u0026#39; firstStr = list(inputTree.keys())[0] secondDict = inputTree[firstStr] featIndex = featLabels.index(firstStr) for key in secondDict.keys(): if testVec[featIndex] == key: if type(secondDict[key]).__name__ == \u0026#39;dict\u0026#39;: classLabel = classify(secondDict[key], featLabels, testVec) else: classLabel = secondDict[key] return classLabel def storeTree(inputTree, filename): fw = open(filename, \u0026#39;wb\u0026#39;) pickle.dump(inputTree, fw) fw.close() def grabTree(filename): fr = open(filename, \u0026#39;rb\u0026#39;) tree = pickle.load(fr) fr.close() return tree def creatDateSet(): dataSet = [ [1, 1, \u0026#39;yes\u0026#39;], [1, 1, \u0026#39;yes\u0026#39;], [1, 0, \u0026#39;no\u0026#39;], [0, 1, \u0026#39;no\u0026#39;], [0, 1, \u0026#39;no\u0026#39;]] labels = [\u0026#39;no surfacing\u0026#39;, \u0026#39;flippers\u0026#39;] return dataSet, labels dataSet , labels = creatDateSet() myTree = createTree(dataSet, labels[:]) storeTree(myTree, \u0026#34;./test.txt\u0026#34;) #newTree = grabTree(\u0026#34;./test.txt\u0026#34;)  #print( classify(newTree, labels, [1, 1]) )  #print(myTree)  画图部分  import matplotlib.pyplot as plt #绘制树的结点 #定义文本框和箭头格式 decisionNode = dict(boxstyle=\u0026#34;sawtooth\u0026#34;, fc=\u0026#34;0.8\u0026#34;) leafNode = dict(boxstyle=\u0026#34;round4\u0026#34;, fc=\u0026#34;0.8\u0026#34;) arrow_args = dict(arrowstyle=\u0026#34;\u0026lt;-\u0026#34;) def plotNode(nodeTxt, centerPt, parentPt, nodeType): \u0026#39;\u0026#39;\u0026#39;绘制带箭头的注解\u0026#39;\u0026#39;\u0026#39; # annotate是关于一个数据点的文本  # nodeTxt为要显示的文本，centerPt为文本的中心点，箭头所在的点，parentPt为指向文本的点  #annotate的作用是添加注释，nodetxt是注释的内容， #nodetype指的是输入的节点（边框）的形状 createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=\u0026#39;axes fraction\u0026#39;, xytext=centerPt, \\ textcoords=\u0026#39;axes fraction\u0026#39;, va=\u0026#34;center\u0026#34;, ha=\u0026#34;center\u0026#34;, bbox=nodeType, arrowprops=arrow_args) def plotMidText(cntrPt,parentPt,txtString): #作用是计算tree的中间位置  # cntrpt起始位置, parentpt终止位置, txtstring：文本标签信息 #找到x和y的中间位置 xmid = (parentPt[0] - cntrPt[0])/2.0 + cntrPt[0] ymid=(parentPt[1]-cntrPt[1])/2.0+cntrPt[1] createPlot.ax1.text(xmid,ymid,txtString) def plotTree(myTree,parentPt,nodetxt): numleafs=getNumLeafs(myTree) depth=getTreeDepth(myTree) firststr=list(myTree.keys())[0] cntrpt=(plotTree.xoff+(1.0+float(numleafs))/2.0/plotTree.totalw,plotTree.yoff)#计算子节点的坐标  plotMidText(cntrpt,parentPt,nodetxt) #绘制线上的文字  plotNode(firststr,cntrpt,parentPt,decisionNode)#绘制节点  seconddict=myTree[firststr] plotTree.yoff=plotTree.yoff-1.0/plotTree.totald#每绘制一次图，将y的坐标减少1.0/plotTree.totald，间接保证y坐标上深度的 for key in seconddict.keys(): if type(seconddict[key]).__name__==\u0026#39;dict\u0026#39;: plotTree(seconddict[key],cntrpt,str(key)) else: plotTree.xoff=plotTree.xoff+1.0/plotTree.totalw plotNode(seconddict[key],(plotTree.xoff,plotTree.yoff),cntrpt, leafNode) plotMidText((plotTree.xoff,plotTree.yoff),cntrpt,str(key)) plotTree.yoff=plotTree.yoff+1.0/plotTree.totald def createPlot(intree): # 类似于Matlab的figure，定义一个画布(暂且这么称呼吧)，背景为白色  fig=plt.figure(1,facecolor=\u0026#39;white\u0026#39;) fig.clf() # 把画布清空  axprops=dict(xticks=[],yticks=[]) # createPlot.ax1为全局变量，绘制图像的句柄，subplot为定义了一个绘图，111表示figure中的图有1行1列，即1个，最后的1代表第一个图  # frameon表示是否绘制坐标轴矩形  createPlot.ax1=plt.subplot(111,frameon=False,**axprops) plotTree.totalw=float(getNumLeafs(intree)) plotTree.totald=float(getTreeDepth(intree)) plotTree.xoff=-0.6/plotTree.totalw;plotTree.yoff=1.2; plotTree(intree,(0.5,1.0),\u0026#39;\u0026#39;) plt.show() def getNumLeafs(myTree): \u0026#39;\u0026#39;\u0026#39;得到树的叶节点数目\u0026#39;\u0026#39;\u0026#39; numLeafs = 0 firstStr = list(myTree.keys())[0] #由于dict_keys是不可索引的对象，所以转换成list  secondDict = myTree[firstStr] for key in secondDict.keys(): #如果结点数据类型是字典 if type(secondDict[key]).__name__ == \u0026#39;dict\u0026#39;: numLeafs += getNumLeafs(secondDict[key]) else: numLeafs += 1 return numLeafs def getTreeDepth(myTree): \u0026#39;\u0026#39;\u0026#39;得到树的层数\u0026#39;\u0026#39;\u0026#39; maxDepth = 0 firstStr = list(myTree.keys())[0] secondDict = myTree[firstStr] for key in secondDict.keys(): if type(secondDict[key]).__name__ == \u0026#39;dict\u0026#39;: thisDepth = getTreeDepth(secondDict[key]) + 1 else: thisDepth = 1 maxDepth = max([maxDepth, thisDepth]) return maxDepth tree = {\u0026#39;no surfacing\u0026#39;: {0: \u0026#39;no\u0026#39;, 1: {\u0026#39;flippers\u0026#39;: {0: \u0026#39;no\u0026#39;, 1: \u0026#39;yes\u0026#39;}}}} createPlot(tree) "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/",
	"title": "机器学习",
	"tags": [],
	"description": "",
	"content": "简介  以记录机器学习的代码实现为主  "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E7%AE%97%E6%B3%95/",
	"title": "算法",
	"tags": [],
	"description": "",
	"content": "简介  本栏目期望能够长期更新，用于记录算法和数据结构。 主要内容是做过的题和代码。 由于本人从大学才开始接触算法，并且在学校被虐的死去活来QAQS，因此题目多为模板题。  "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E8%B4%AA%E5%BF%83/radar-installation/",
	"title": "Radar Installation",
	"tags": [],
	"description": "",
	"content": "题目链接 百练 Radar Installation\n题目描述  有n个岛屿的x,y坐标，要往x轴上装雷达，已知雷达与岛屿的有效距离d。求最少装几个雷达，能覆盖全部岛屿。如果没有解，输出-1  解题思路  贪心 首先利用坐标和d计算每个岛屿对应的有效雷达在x轴上的区间。 将区间按右端点从小到大排序，右端点相同的，按左端点从大到小排序。 首先在0号区间的右端点装雷达，然后判断它能覆盖几个区间。遇到不能覆盖的区间，就在它的右端点装个雷达，以此类推。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int n;//n个岛屿 int d;//距离 struct Line { double s; double e; //将区间按右端点从小到大排序，右端点相同的，按左端点从大到小排  bool operator \u0026lt;(const Line\u0026amp; l)const { if (e == l.e) { return s \u0026gt; l.s; } return e \u0026lt; l.e; } }; Line line[1010]; Line getLine(int x, int y); int main() { int kase = 0; while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;d)) { if (n == 0 \u0026amp;\u0026amp; d == 0) break; int i, j; int x, y; kase++; bool noAns = 0; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if (y \u0026gt; d) { noAns = 1; } else { line[i] = getLine(x, y); } } if (noAns) { printf(\u0026#34;Case %d: -1\\n\u0026#34;, kase); continue;//注意这里不是break  } sort(line, line + n); int total = 1; int temp = 0; for (i = 1; i \u0026lt; n; ++i) { if (line[i].s \u0026gt; line[temp].e) { temp = i; total++; } } printf(\u0026#34;Case %d: %d\\n\u0026#34;, kase, total); } return 0; } Line getLine(int x, int y) { Line temp; temp.s = (double)x - sqrt(d * d - y * y); temp.e = (double)x + sqrt(d * d - y * y); return temp; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E8%B4%AA%E5%BF%83/%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E7%9A%84%E7%A4%BC%E7%89%A9/",
	"title": "圣诞老人的礼物",
	"tags": [],
	"description": "",
	"content": "题目链接 百练 圣诞老人的礼物\n题目描述  可以拿部分物品的背包问题。  解题思路  贪心 计算每件物品的价值与重量的比值，并从大到小排序。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int n; int w; struct Candy { int w; int val; double ratio; bool operator \u0026lt;(const Candy\u0026amp; c)const { return ratio \u0026gt; c.ratio; } }; Candy candies[110]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;w); int i; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;candies[i].val, \u0026amp;candies[i].w); candies[i].ratio = (double)candies[i].val / (double)candies[i].w; } sort(candies, candies + n); int totalW = 0; double totalV = 0; for (i = 0; i \u0026lt; n; ++i) { if (totalW + candies[i].w \u0026lt;= w) { totalW += candies[i].w; totalV += candies[i].val; } else { totalV += candies[i].ratio * (w - totalW); break; } } printf(\u0026#34;%.1f\\n\u0026#34;, totalV); return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E8%B4%AA%E5%BF%83/%E7%94%B5%E5%BD%B1%E8%8A%82/",
	"title": "电影节",
	"tags": [],
	"description": "",
	"content": "题目链接 百练 电影节\n题目描述  给一堆电影的开始时间和结束时间，问最多可以看几部电影  解题思路  贪心 按电影的结束时间先后排序。从第一个电影开始看，结束后就看下一个能看的电影。注意一个电影的结束时间和另一个的开始时间能重合。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int n; struct Movie { int s; int e; bool operator \u0026lt;(const Movie\u0026amp; m)const { return e \u0026lt; m.e; } }; Movie mve[1010];//电影的开始时间和结束时间 int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) { if (!n) { break; } int i; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;mve[i].s, \u0026amp;mve[i].e); } sort(mve, mve + n); int end = 0; int total = 0; for (i = 0; i \u0026lt; n; ++i) { if (end \u0026lt;= mve[i].s) { ++total; end = mve[i].e; } } printf(\u0026#34;%d\\n\u0026#34;, total); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E8%B4%AA%E5%BF%83/stall-reservations/",
	"title": "Stall Reservations",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ3190 Stall Reservations\n题目描述  有n头牛挤奶，已知每头牛挤奶的开始时间和结束时间。每个牛都要在一个畜栏中挤奶，一个畜栏同一时间只能放一头牛。哪怕挤奶时间的区间端点重合也不行。 问至少需要多少畜栏，每头牛都放在哪个畜栏里。  解题思路  贪心 首先将奶牛按挤奶的开始时间排序。 为第一个奶牛分配畜栏。 依次处理后面的每一个奶牛i。在处理i时，考虑已分配的畜栏中，结束时间最早的畜栏x。  如果End(x)\u0026lt;Start(i), 则不分配新畜栏。 如果End(x)\u0026gt;=Start(i),则分配新畜栏。   用优先队列维护已经分配的畜栏。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int n; struct Cow { int a, b;//挤奶区间起始点  int No;//编号  bool operator \u0026lt;(const Cow\u0026amp; c)const { return a \u0026lt; c.a; } }; struct Stall { int end;//结束时间  int No;//畜栏编号  bool operator \u0026lt;(const Stall\u0026amp; s) const { return end \u0026gt; s.end; } Stall(int e, int n) :end(e), No(n) {} }; Cow cows[50010]; int pos[50010];//pos[i]为第i个奶牛的畜栏编号  int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int i, j; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;cows[i].a, \u0026amp;cows[i].b); cows[i].No = i; } sort(cows, cows + n); priority_queue\u0026lt;Stall\u0026gt; pq; int total = 0; for (i = 0; i \u0026lt; n; ++i) { if (pq.empty()) { total++; pq.push(Stall(cows[i].b, total)); pos[cows[i].No] = total; } else { Stall st = pq.top(); if (st.end \u0026lt; cows[i].a) { pq.pop(); st.end = cows[i].b; pos[cows[i].No] = st.No; pq.push(st); } else { ++total; pq.push(Stall(cows[i].b, total)); pos[cows[i].No] = total; } } } printf(\u0026#34;%d\\n\u0026#34;, total); for (i = 0; i \u0026lt; n; ++i) { printf(\u0026#34;%d\\n\u0026#34;, pos[i]); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E8%B4%AA%E5%BF%83/best-cow-line/",
	"title": "Best Cow Line",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ3617 Best Cow Line\n题目描述  奶牛题，抽象出来就是，给定长度为N的字符串S，要构造出一个长度N的字符串T。构造方式是：从S的头部或尾部删除一个字符，加到T的尾部 求字典序最小的T，每次输出80个字符后换行  解题思路  贪心，每次比较剩余的S串的头尾，选小的加入T的尾部。 要注意到头尾相同的情况，这是要接着往里比较，因为我们希望尽可能早使用更小的字符。 可以用a,b初始时指向S串的头尾，然后不断往里缩。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int N; char s[10010]; char t[10010]; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); getchar(); int i; for (i = 0; i \u0026lt; N; ++i) { scanf(\u0026#34;%c\u0026#34;, \u0026amp;s[i]); getchar(); } int j = 0; int a = 0; int b = N - 1; //指向初始s的头尾，往里缩  while (a \u0026lt;= b) { bool left = false; //如果头尾相同，就不断往里找  for (i = 0; a + i \u0026lt;= b; ++i) { if (s[a + i] \u0026lt; s[b - i]) { left = true; break; } else if (s[a + i] \u0026gt; s[b - i]) { left = false; break; } } if (left) { t[j] = s[a]; a++; j++; } else { t[j] = s[b]; b--; j++; } } t[N] = \u0026#39;\\0\u0026#39;; for (int i = 0; i \u0026lt; N; ++i) { if (i % 80 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%c\u0026#34;, t[i]); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E8%B4%AA%E5%BF%83/",
	"title": "贪心",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%85%B6%E5%AE%83%E8%A7%A3%E6%B3%95/ants/",
	"title": "Ants",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ1852 Ants\n题目描述  有一个长为L的杆子，上面有n个蚂蚁。每个蚂蚁的初始位置给定。蚂蚁以单位速度在杆子上走，如果两个蚂蚁碰到，就各自反向走。 求所有蚂蚁落下杆子所需的最短时间和最长时间  解题思路  发现两个蚂蚁相遇后，让它们保持原样交错而过、继续前进对本题的解没有影响 因此最短时间和最长时间，都只要对每一只蚂蚁检查一次即可  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int L;//杆子长度 int n; int a[1000010]; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;L, \u0026amp;n); int i; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } int minT = 0; int maxT = 0; //计算所有蚂蚁落下的最短时间  for (i = 0; i \u0026lt; n; ++i) { minT = max(minT, min(a[i], L - a[i])); } //计算最长时间  for (i = 0; i \u0026lt; n; ++i) { maxT = max(maxT, max(a[i], L - a[i])); } printf(\u0026#34;%d %d\\n\u0026#34;, minT, maxT); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%85%B6%E5%AE%83%E8%A7%A3%E6%B3%95/",
	"title": "其它解法",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%90%9C%E7%B4%A2/%E5%85%A8%E6%8E%92%E5%88%97/",
	"title": "全排列",
	"tags": [],
	"description": "",
	"content": "题目描述 求1~n的全排列\n解题思路  用dfs枚举全排列  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; int result[200]; int N; int used[200]; /*用dfs生成全排列*/ void permutation1(int k); /*优化后的全排列生成,但不是按顺序生成的， 思路： 求 S = {a1,a2,a3..an}的全排列，等于: for (int i = 1; i \u0026lt;= n; ++i ) { for x in (S – ai) 的每个排列 cout \u0026lt;\u0026lt; ai + x; } */ template\u0026lt;class T\u0026gt; void permutation2(T start, T end, T k) { //输出[start,k)固定的全排列  if (k == end) { for (start; start != end; ++start) { cout \u0026lt;\u0026lt; *start \u0026lt;\u0026lt; \u0026#34;\u0026#34;; } cout \u0026lt;\u0026lt; endl; return; } for (T i = k; i != end; ++i) { swap(*k, *i); permutation2(start, end, k + 1); swap(*k, *i); } } int a[200]; int main() { cin \u0026gt;\u0026gt; N; permutation1(0); for (int i = 0; i \u0026lt; N; ++i) { a[i] = i + 1; } permutation2(a, a + N, a); return 0; } void permutation1(int k) { if (k == N) { for (int i = 0; i \u0026lt; N; ++i) { cout \u0026lt;\u0026lt; result[i] \u0026lt;\u0026lt; \u0026#34;\u0026#34;; } cout \u0026lt;\u0026lt; endl; return; } for (int i = 1; i \u0026lt;= N; ++i) { if (!used[i]) { result[k] = i; used[i] = 1; permutation1(k + 1); used[i] = 0; } } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%90%9C%E7%B4%A2/lake-counting/",
	"title": "Lake Counting",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ2386 Lake Counting\n题目描述 一个N*M的院子，雨后有积水。八连通的积水被认为是在一起的。求总共多少个水洼？\n解题思路  用dfs遍历院子，进行染色。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; char maze[110][110]; int visit[110][110]; int color; int n;//n行 int m;//m列 int go[8][2] = { {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {-1, -1},{0, -1}, {1, -1} }; void dfs(int x, int y); int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int i, j; color = 0; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%s\u0026#34;, maze[i]); } for (i = 0; i \u0026lt; n; ++i) { for (j = 0; j \u0026lt; m; ++j) { if (!visit[i][j] \u0026amp;\u0026amp; maze[i][j] == \u0026#39;W\u0026#39;) { color++; dfs(i, j); } } } printf(\u0026#34;%d\\n\u0026#34;, color); return 0; } void dfs(int x, int y) { visit[x][y] = 1; int i; for (i = 0; i \u0026lt; 8; ++i) { int xx = x + go[i][0]; int yy = y + go[i][1]; if (xx \u0026gt;= 0 \u0026amp;\u0026amp; xx \u0026lt; n \u0026amp;\u0026amp; yy \u0026gt;= 0 \u0026amp;\u0026amp; yy \u0026lt; m \u0026amp;\u0026amp; maze[xx][yy] == \u0026#39;W\u0026#39; \u0026amp;\u0026amp; !visit[xx][yy]) { dfs(xx, yy); } } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%90%9C%E7%B4%A2/",
	"title": "搜索",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%90%9C%E7%B4%A2/%E9%83%A8%E5%88%86%E5%92%8C%E9%97%AE%E9%A2%98/",
	"title": "部分和问题",
	"tags": [],
	"description": "",
	"content": "题目描述 给定n(n\u0026lt;20)个数，判断是否可以从中选出若干个数，使他们的和为k。\n解题思路  用dfs枚举可能的组合  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; const int MAXN = 30; int n;//n个数 int k; int a[MAXN]; bool dfs(int x, int sum); int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int i; for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); bool ans; ans = dfs(0, 0); if (ans) { printf(\u0026#34;Yes\\n\u0026#34;); } else printf(\u0026#34;No\\n\u0026#34;); return 0; } bool dfs(int x, int sum) { if (x == n) { if (sum == k) return true; return false; } //不加上a[x]  if (dfs(x + 1, sum)) return true; //加上a[x]  if (dfs(x + 1, sum + a[x])) return true; return false; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/",
	"title": "并查集",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/",
	"title": "单调栈与单调队列",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
	"title": "动态规划",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%9D%82%E8%B0%88/",
	"title": "杂谈",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%9D%82%E8%B0%88/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%8F%98%E9%87%8F%E5%90%8D%E5%91%BD%E5%90%8D%E6%8C%87%E5%8D%97/",
	"title": "算法竞赛变量名命名指南",
	"tags": [],
	"description": "",
	"content": " 参考黄学长的博客 算法竞赛的代码的确和其它大作业、工程代码等不一样，时间紧任务重，所以一般命名都是缩写，只有当事人能看明白那种。 但是太简略了可能自己都搞蒙了。所以可参考以下命名方法：   add 加 anc, ancestor 祖先 ans, answer 答案 bel, belong 属于 best 最佳的 build 建立 block 障碍 ch, char 字符 check 判定 color 颜色 cmp, compare 比较 cnt, count 计数器 cur, current 当前量 deg, degree 度数 dep, depth 深度 del, delete 删除 delta 增量 diff, difference 差别 dist, distance 距离 div, division 除法，部分 dp 动态规划 edge 边 extra 额外的 fa, father 父亲 factor 因子 flag 标志 flow 流 from 来自 get 得到 Hash 哈希表（hash是保留字） heap 堆 in 入 ind, index 标号 inq 在队列里 inf, infinity 无穷大 init, initialize 初始化 insert 插入 inv, inverse 翻转，颠倒 last 最后一个 len, length 长度 lim, limit 极限 low, lower 下边的 mat, matrix 矩阵 mid, middle 中间量 mod 模 modify 修改 mp, map 映射 mst 最小生成树 mul, multiply 乘法 node 结点 num, number 数量 nxt 后继（next是保留字） out 出 pa, pair 对子 pre, precursor 前驱 prime 质数 pos, position 位置 prod, product 乘积 put 放置 que, queue 队列 query 询问 rank 秩 res, result 结果 res, residual 剩余 scc 强连通分量 size 大小 split 分裂 start 开始 stk, stack 栈 str 字符串 suc, succeed 后继 sum 和 tim 时间（time是保留字） tmp, temporary 临时量 tree 树 to 表目的 unite 联合 up, upper 上边的 update 更新 used 使用过的 val, value 值 vec, vector 向量 vis, visit 访问 zero 零 "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E4%BA%8C%E5%88%86/%E5%80%9F%E6%95%99%E5%AE%A4/",
	"title": "借教室",
	"tags": [],
	"description": "",
	"content": "题目链接 借教室\n题目描述  有n天，m个借教室的订单。每个订单有d,s,t三项，分别是租借的数量，租借开始、结束分别在第几天。 借教室按照先来后到的原则，但是可能到某个订单时，剩余教室不足，因此无法满足订单内容。 如果所有订单均可满足，则输出只有一行，包含一个整数0。否则输出两行，第一行输出一个负整数−1，第二行输出需要修改的订单编号。  解题思路  首先，此题中每个订单相当于对一个区间的内容整体加/减一个数，因此容易想到用差分。 本题巧妙地使用了二分答案的思想。对于能否二分，有一个界定标准：状态的决策过程或者序列是否满足单调性或者可以局部舍弃性。而在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。 因此，本题思路如下，二分枚举可能的答案d。每次都利用差分思想，计算为了满足从1到d的订单，每日所需的教室数量。然后根据实际的教室数量判断其能否满足。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int n, m;//天数和订单数量 int num[1000010];//num[i]表示第i天可租借教室数量 int need[1000010];//need[i]表示第i天需要的教室数量 int diff[10000100];//need的差分,从而快速计算出need[i] struct Order {//订单  int d, s, t; }; Order odr[1000010]; bool judgeOrder(int d); int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int i = 0; for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;num[i]); } for (i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;odr[i].d, \u0026amp;odr[i].s, \u0026amp;odr[i].t); } int left = 1; int right = m; int mid; int ans; ans = 0; //首先判断所有订单是否均能满足  if (judgeOrder(m)) { printf(\u0026#34;0\\n\u0026#34;); } else { while (left \u0026lt;= right) { mid = (left + right) / 2; if (judgeOrder(mid)) { left = mid + 1; } else { ans = mid; right = mid - 1; } } printf(\u0026#34;-1\\n%d\\n\u0026#34;, ans); } return 0; } bool judgeOrder(int d) { memset(diff, 0, sizeof(diff)); int i; //求差分  for (i = 1; i \u0026lt;= d; ++i) { diff[odr[i].s] += odr[i].d; diff[odr[i].t + 1] -= odr[i].d; } //利用差分计算出从第1个订单到第d个订单，每天需要的教室数量，  //并进行判断  for (i = 1; i \u0026lt;= n; ++i) { need[i] = need[i - 1] + diff[i]; if (need[i] \u0026gt; num[i]) return false; } return true; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E4%BA%8C%E5%88%86/%E8%B7%B3%E7%9F%B3%E5%A4%B4/",
	"title": "跳石头",
	"tags": [],
	"description": "",
	"content": "题目链接 跳石头\n题目描述  已知起点到终点距离为L, 有N块岩石。组委会计划移走至多M块岩石，让选手的最短跳跃距离尽可能长。 求最短跳跃距离的最大值。  解题思路  一般求最短距离的最大值，或者最大距离的最小值，都用二分答案的方法。 注意此题中移走的M块岩石不包括起点和终点，在模拟时可将起点和终点的岩石加上。 注意二分答案的写法。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int L;//起点到终点的距离 int N;//石头数 int M;//组委会至多移动走的石头数 int a[50010];//a[i]表示第i个石头离起点的距离 bool judgeDis(int d); int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;L, \u0026amp;N, \u0026amp;M); int i; for (i = 1; i \u0026lt;= N; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } a[0] = 0; a[N + 1] = L; int left = 0; int right = L; int mid; int ans; while (left \u0026lt;= right) { mid = (left + right) / 2; if (judgeDis(mid)) { ans = mid; left = mid + 1; } else { right = mid -1 ; } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } bool judgeDis(int d) { int now = 0;//人当前的位置  int tol = 0;//总共需要移动的岩石数  int i = 1; while (i \u0026lt;= N) { if (a[i] - a[now] \u0026lt; d) { i++; tol++; } else { now = i; i++; } } return (tol \u0026lt;= M); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E4%BA%8C%E5%88%86/",
	"title": "二分",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%95%B0%E8%AE%BA/%E5%8C%BA%E9%97%B4%E7%AD%9B%E6%B3%95/",
	"title": "区间筛法",
	"tags": [],
	"description": "",
	"content": "题目描述 求区间[a, b)内素数个数？其中a, b范围为1e12, b-a的范围是1e6\n解题思路  利用素数筛法。b以内的合数的最小质因数一定不超过sqrt(b)。因此在[2, sqrt(b))上筛素数的同时，也可将[a,b)中的合数筛去。 因为题中a,b较大，所以构建[a, b)的表需要映射成0~b-a。 题中的乘法需要long long范围，因此可将所有数都用long long范围。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; typedef long long ll; const long long MAXN = 1e6 + 10; bool is_prime[MAXN];//is_prime[i - a]判断i是否为素数，筛[a, b) bool is_prime_small[MAXN];//is_prime_small[i]判断i是否为素数,筛[2, sqrt(b))  /* 对区间[a, b)内的整数进行筛法 */ ll segment_sieve(ll a, ll b) { for(ll i = 0; i * i \u0026lt; b; ++i){ is_prime_small[i] = true; } for(ll i = 0, j = b - a; i \u0026lt; j; ++i){ is_prime[i] = true; } for(ll i = 2; i * i \u0026lt; b; ++i){ if(is_prime_small[i]){ //筛[2, sqrt(b))  for(ll j = 2*i; j * j \u0026lt; b; j += i){ is_prime_small[j] = false; } //筛[a, b)  for(ll j = max((a + i - 1)/i, 2LL)*i; j \u0026lt; b; j += i){ is_prime[j - a] = false; } } } ll ans = 0; for(ll i = 0, j = b - a; i \u0026lt; j; ++i){ if(is_prime[i]) ans++; } return ans; } int main() { ll a, b; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b); ll ans = segment_sieve(a, b); printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%95%B0%E8%AE%BA/carmichael-numbers/",
	"title": "Carmichael Numbers",
	"tags": [],
	"description": "",
	"content": "题目链接 Carmichael Numbers\n题目描述 如果对任意的 1 \u0026lt; x \u0026lt; n 都有 x^n≡x(mod n)成立的合数n称为Carmichael Numbers。给出一些整数n,请判断是否为Carmichael Numbers，其中2 \u0026lt; n \u0026lt; 65000\n解题思路  首先判断n是否为合数 利用快速幂计算x^n  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; typedef long long ll; /* 判断是否为质数 */ bool is_primer(int n) { for(int i = 2; i*i \u0026lt;= n; ++i){ if(n %i == 0) return false; } return true; } /* 快速幂 */ ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while(n \u0026gt; 0){ if(n \u0026amp; 1){ res = res * x % mod; } x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } int main() { ll n; bool flag = 1; ll ans; while(1){ flag = 1; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); if(!n) break; //如果n是质数  if(is_primer((int)n)){ printf(\u0026#34;%lld is normal.\\n\u0026#34;, n); } else{ for(ll x = 2; x \u0026lt; n; ++x){ ans = mod_pow(x, n, n); if(ans != x){ flag = 0; break; } } if(flag) printf(\u0026#34;The number %lld is a Carmichael number.\\n\u0026#34;, n); else printf(\u0026#34;%lld is normal.\\n\u0026#34;, n); } } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%95%B0%E8%AE%BA/%E5%9F%83%E5%BC%8F%E7%AD%9B%E6%B3%95/",
	"title": "埃式筛法",
	"tags": [],
	"description": "",
	"content": "题目描述 给定数n，求n以内的素数个数\n解题思路  利用筛法求素数，首先假设3~n均为素数。由于对于一个数i，如果i是素数，则2i,3i\u0026hellip;\u0026hellip;均不是素数。利用此方法筛选后，剩下的就是素数  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; const int MAXN = 1000010; int prime[MAXN];//prime[i]为n的第i个素数 bool is_prime[MAXN]; /* 素数筛法，返回n以内的素数的个数 */ int sieve(int n) { int p = 0; int i, j; for(i = 0; i \u0026lt;= n; ++i){ is_prime[i] = true; } is_prime[0] = is_prime[1] = false; for(i = 2; i \u0026lt;= n; ++i){ if(is_prime[i]){ prime[++p] = i; for(j = 2*i; j \u0026lt;= n; j += i){ is_prime[j] = false; } } } return p; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = sieve(n); printf(\u0026#34;%d\\n\u0026#34;, ans); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%95%B0%E8%AE%BA/%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A/",
	"title": "素数判定",
	"tags": [],
	"description": "",
	"content": "题目描述 给定数n，判断n是否为素数；求n的约数；求n的整数分解形式\n解题思路  枚举n可能的约数  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;#include\u0026lt;map\u0026gt;using namespace std; /* 素数测试判断素数 */ bool isPrime1(int n) { if(n == 1) return false; int k = sqrt(n); for (int i = 2; i \u0026lt;= k; ++i){ if(n % i == 0) return false; } return true; } /* 约数枚举 */ vector\u0026lt;int\u0026gt; divisor(int n) { vector\u0026lt;int\u0026gt; res; int k = sqrt(n); for(int i = 1; i \u0026lt;= k; ++i){ if(n % i == 0){ res.push_back(i); if(i != n/i) res.push_back(n/i); } } return res; } /* 整数分解 */ map\u0026lt;int, int\u0026gt; prime_factor(int n){ map\u0026lt;int, int\u0026gt; res; //记录n的每个约数及该约数的个数  //由于整数分解时n是变的，因此用i*i \u0026lt;= n判断  for(int i = 2; i * i \u0026lt;= n; ++i){ while(n % i == 0){ ++res[i]; n /= i; } } if(n != 1) res[n] = 1; return res; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%95%B0%E8%AE%BA/%E5%8F%8C%E5%85%AD/",
	"title": "双六",
	"tags": [],
	"description": "",
	"content": "题目描述 一个双六上面有向前向后无线延续的格子，每个格子都写有整数。其中0号是起点，1号是终点。输入整数a和b，一个骰子只有a,b,-a,-b四个 整数。问抛出四个数多少次可到达终点？如果解不唯一，输出一组即可。如果无解，输出-1。\n解题思路  即求整数x,y使得ax+by=1。 有解条件为gcd(a, b)=1。 利用扩展的欧几里得算法可求解。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; /* 扩展欧几里得算法，在求gcd(a, b)的同时， 求出一对(x, y)满足a*x + b*y = gcd(a, b) */ int extgcd(int a, int b, int\u0026amp; x, int\u0026amp; y) { int d = a; if(b != 0){ d = extgcd(b, a%b, y, x); y -= (a/b) * x; } else{ x = 1; y = 0; } return d; } int main() { int a, b; int x, y; int n1, n2, n3, n4; // 对应a, b, -a, -b的个数  scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); int d; d = extgcd(a, b, x, y); if(d != 1){ printf(\u0026#34;-1\\n\u0026#34;); } else{ n1 = n2 = n3 = n4 = 0; if(x \u0026gt; 0) n1 = x; else n3 = -x; if(y \u0026gt; 0) n2 = y; else n4 = -y; printf(\u0026#34;%d%d%d%d\\n\u0026#34;, n1, n2, n3, n4); } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%95%B0%E8%AE%BA/%E7%BA%BF%E6%AE%B5%E4%B8%8A%E7%9A%84%E6%A0%BC%E7%82%B9%E6%95%B0/",
	"title": "线段上的格点数",
	"tags": [],
	"description": "",
	"content": "题目描述 给定平面上的两个格点P和Q的坐标。求线段PQ除端点以外一共有多少个格点？\n解题思路  答案是线段x轴投影长度与y轴投影长度的最大公约数-1 注意特判P与Q重合的情况  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; /*辗转相除法，求a和b的最大公约数*/ int gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b); } int main() { int x1, y1, x2, y2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); int dx = abs(x1 - x2); int dy = abs(y1 - y2); int ans; if(!dx \u0026amp;\u0026amp; !dy){ //特判dx==0\u0026amp;\u0026amp;dy==0的情况  ans = 0; } else{ ans = gcd(dx, dy) - 1; } printf(\u0026#34;%d\\n\u0026#34;, ans); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E6%95%B0%E8%AE%BA/",
	"title": "数论",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E7%BA%BF%E6%AE%B5%E6%A0%91/%E5%8C%BA%E9%97%B4%E6%8A%91%E6%88%96/",
	"title": "ZGOJ1561 区间抑或",
	"tags": [],
	"description": "",
	"content": "题目链接 打不开了\n题目描述  忘了  解题思路  利用线段树，区间操作注意用延迟更新，包括向下更新和向上更新。 注意要用unsigned int。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int a[100010]; unsigned int b; int n;//n个数 int m;//m个查询 struct Node { int L, R; int sum;//区间的抑或和 \tint lazy; int val; int Mid() { return (L + R) / 2; } }; Node tree[400010]; void build_tree(int root, int l, int r) { tree[root].L = l; tree[root].R = r; tree[root].lazy = 0; tree[root].val = 0; if (l == r) { tree[root].sum = a[l]; tree[root].val = a[l]; return; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); build_tree(lc, l, mid); build_tree(rc, mid + 1, r); tree[root].sum = tree[lc].sum ^ tree[rc].sum; } int query_tree(int root, int l, int r) { if (tree[root].L \u0026lt;= l \u0026amp;\u0026amp; tree[root].R \u0026gt;= r \u0026amp;\u0026amp; tree[root].lazy) { if ((r - l +1) % 2) { return tree[root].val; } else { return 0; } } if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { return tree[root].sum; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); if (r \u0026lt;= mid) { return query_tree(lc, l, r); } else if (l \u0026gt; mid) { return query_tree(rc, l, r); } else { return (query_tree(lc, l, mid) ^ query_tree(rc, mid + 1, r)); } } void change_tree(int root, int l, int r, int num) { if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { tree[root].val = num; tree[root].lazy = 1; if ((r - l +1 ) % 2) { tree[root].sum = num; } else tree[root].sum = 0; return; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); if (tree[root].lazy) { tree[root].lazy = 0; tree[lc].lazy = tree[rc].lazy = 1; tree[lc].val = tree[rc].val = tree[root].val; if ((tree[lc].R - tree[lc].L + 1) % 2) { tree[lc].sum = tree[lc].val; } else tree[lc].sum = 0; if ((tree[rc].R - tree[rc].L + 1) % 2) { tree[rc].sum = tree[rc].val; } else tree[rc].sum = 0; } if (r \u0026lt;= mid) { change_tree(lc, l, r, num); } else if (l \u0026gt; mid) { change_tree(rc, l, r, num); } else { change_tree(lc, l, mid, num); change_tree(rc, mid + 1, r, num); } tree[root].sum = tree[lc].sum ^ tree[rc].sum; //tree[root].lazy = 0; \treturn; } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); int i, j; unsigned int ans;//注意要用unsigned int !!! \twhile (T--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(tree, 0, sizeof(tree)); memset(a, 0, sizeof(a)); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%u\u0026#34;, \u0026amp;b); a[i] = (int)b; } build_tree(1, 1, n); char s[3]; int a, b, x; for (i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%s\u0026#34;, s); if (s[0] == \u0026#39;C\u0026#39;) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;x); change_tree(1, a, b, x); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); ans = query_tree(1, a, b); printf(\u0026#34;%u\\n\u0026#34;, ans); } } printf(\u0026#34;\\n\u0026#34;); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/",
	"title": "HomePage",
	"tags": [],
	"description": "",
	"content": "欢迎来到ZJQ的博客  本博客是基于hugo框架搭建的静态博客。本人第一次搭博客，动态博客也写不来，而且也设计不出这些主题。 博客内容以学习为主，经初步构思，本博客主要用来记录算法、计算机知识、电脑使用知识等。 佛系更新，更新快说明在认真学习ing，更新慢说明在摸鱼\u0026hellip;\u0026hellip; 祝大家开心快乐，学习进步！  "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E7%BA%BF%E6%AE%B5%E6%A0%91/majors_poster/",
	"title": "POJ2528 Mayor&#39;s poster",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ2528 Mayor\u0026rsquo;s poster\n题目描述  用多张海报贴一面墙，求贴完后有几张海报是可见的（完全可见+部分可见）。 题目有多组数据。 对于每组数据有n个海报，每个海报给定左、右端点，并按照贴的顺序给出。  解题思路  利用线段树，注意处理顺序是由外层到内层。因为外层覆盖的区间会影响内层的可见情况，而内层覆盖的区间不会影响外层的可见情况。 注意延迟更新  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; struct Node { int L, R; bool covered; int Mid() { return L + (R - L) / 2; } }; struct Line { int s, e; }; Line poster[10010];//记录海报 int disc[40010];//用于离散化 Node tree[160010];//线段树 int point[40010];//记录海报的两个端点，用于离散化 int point_num;//记录去重后的端点个数 void build_tree(int root, int l, int r); bool query_tree(int root, int l, int r); int main() { int c; int n;//c个样例，n个海报 \tscanf(\u0026#34;%d\u0026#34;, \u0026amp;c); int ans; int i, j; while (c--) { ans = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;poster[i].s, \u0026amp;poster[i].e); point[2 * i] = poster[i].s; point[2 * i + 1] = poster[i].e; } sort(point, point + 2 * n); point_num = unique(point, point + 2 * n) - point; int dcnt = 0; disc[dcnt] = point[0]; dcnt++; //离散化，要把两个端点中间的区间也离散化成一个区间， \t//因此如果(point[i]-point[i-1]\u0026gt;1)，就把point[i-1]+1当一个新区间 \tfor(i = 1; i \u0026lt; point_num; ++i){ if( (point[i] - point[i-1]) \u0026gt; 1){ disc[dcnt] = point[i-1]+1;\tdcnt++; } disc[dcnt] = point[i]; dcnt++; } build_tree(1, 1, dcnt); int nl, nr; for(i = n - 1; i \u0026gt;= 0; --i){ nl = lower_bound(disc, disc + dcnt, poster[i].s) - disc + 1; nr = lower_bound(disc, disc + dcnt, poster[i].e) - disc + 1; if(!query_tree(1, nl, nr) ){ ans++; } } printf(\u0026#34;%d\\n\u0026#34;, ans); } } void build_tree(int root, int l, int r) { tree[root].L = l; tree[root].R = r; tree[root].covered = 0; if (l == r) return; int mid = tree[root].Mid(); build_tree((root \u0026lt;\u0026lt; 1), l, mid); build_tree((root \u0026lt;\u0026lt; 1) | 1, mid + 1, r); return; } bool query_tree(int root, int l, int r) { bool flag = 0; if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { flag = tree[root].covered; tree[root].covered = 1; return flag; } if(tree[root].L \u0026lt;= l \u0026amp;\u0026amp; tree[root].R \u0026gt;= r \u0026amp;\u0026amp; tree[root].covered){ //如果当前区间包裹了要查询的区间，且已经被覆盖了，就直接返回true, \t//因为你第一个是延迟更新，你这里不判断，就跑到下面了 \t//注意这里，错了两次了！！！ \treturn 1; } int mid = tree[root].Mid(); int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; if (r \u0026lt;= mid) { flag = query_tree(lc, l, r); } else if (l \u0026gt; mid) { flag = query_tree(rc, l, r); } else { flag = query_tree(lc, l, mid) \u0026amp; query_tree(rc, mid + 1, r); } //注意更新cover的状态 \ttree[root].covered = tree[lc].covered \u0026amp; tree[rc].covered; return flag; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E7%BA%BF%E6%AE%B5%E6%A0%91/",
	"title": "线段树",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/a-bugs-life/",
	"title": "A Bug&#39;s Life",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ2492 A Bug\u0026rsquo;s Life\n题目描述  有两种性别的虫子。它们只能不同性别间交配。给出一堆虫子的交配列表。判断是否满足只能在不同性别间交配的命题。  解题思路  利用带权并查集，把可以判断出性别关系的虫子放到同一集合中。 在Merge()和GetRoot()函数中更新子结点与根节点的性别关系。 性别关系类似于向量加减，可通过画向量图的方式计算结点间的关系。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;using namespace std; const int MAXN = 2010; int par[MAXN];//par[i]是i的根节点 int rea[MAXN];//rea[i]是i和根节点的关系,0是同性，1是异性 int GetRoot(int a, int r); void Merge(int a, int b, int r); bool Query(int a, int b); int n, m;//n个虫子，m个操作 int main() { int k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); int kase = 0; while(k--){ ++kase; int i, r, x, y; bool flag = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(i = 0;i \u0026lt;= n; ++i){ par[i] = i; rea[i] = 0; } for(i = 0;i \u0026lt; m; ++i){ scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if(!Query(x, y)){ Merge(x, y, 1); } else{ if(rea[x] == rea[y]){ flag = 1; } } } printf(\u0026#34;Scenario #%d:\\n\u0026#34;, kase); if(flag) printf(\u0026#34;Suspicious bugs found!\\n\u0026#34;); else printf(\u0026#34;No suspicious bugs found!\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } } int GetRoot(int a) { if(par[a] == a) return a; int pa = GetRoot(par[a]); rea[a] = (rea[par[a]] + rea[a])%2; par[a] = pa; return pa; } void Merge(int a, int b, int r) { int pa = GetRoot(a); int pb = GetRoot(b); if(pa != pb){ par[pb] = pa; rea[pb] = (rea[a] - r - rea[b] + 4) % 2; } return ; } bool Query(int a, int b) { return GetRoot(a) == GetRoot(b); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/cube-stacking/",
	"title": "Cube stacking",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ1988 Cube stacking\n题目描述  有N堆方块，开始每堆都是一个方块，编号为1~N。有两种操作： M x y: 表示把方块x所在的堆，拿起来叠放到y所在的堆上。 C x：问方块x下面有多少个方块。 操作最多P次。对每次C操作，输出结果。  解题思路  利用并查集。维护sum[]，记录每堆总共的方块数。维护under[],under[i]表示第i个方块下面的方块数。 sum在堆合并的时候更新，under在堆合并和路径压缩的时候更新。 这题相当于：落在上面的方块，在并查集树中是下面的叶子节点。把y所在的堆落到x所在的堆上，相当于y所在的树挂接到x所在的树上。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; //把最下面的块当树根 //把a摞到b上，相当于把a挂接到b上 //记录sum是为了更新under int N; int par[30010];//par[i]表示i的父节点 int sum[30010];//sum[i]表示第i堆总共的方块数 int under[30010];//under[i]表示在i下面的方块数 int Getroot(int x) { if(x == par[x]) return x; int px = Getroot(par[x]); under[x] += under[par[x]]; par[x] = px; return px; } void Merge(int x, int y)//把y所在的堆叠放到x所在的堆上 { int px = Getroot(x); int py = Getroot(y); if(px == py) return; par[py] = px; under[py] = sum[px]; sum[px] += sum[py]; } int main() { int i; for( i = 1; i \u0026lt;= 30000; ++i){ par[i] = i; sum[i] = 1; under[i] = 0; } int P; scanf(\u0026#34;%d\u0026#34;, \u0026amp;P); char s[20]; int a, b; for(int i = 0; i \u0026lt; P; ++i){ scanf(\u0026#34;%s\u0026#34;, s); if(s[0] == \u0026#39;M\u0026#39;){ scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); Merge(b,a); } else{ scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); Getroot(a); printf(\u0026#34;%d\\n\u0026#34;, under[a]); } } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/the-suspects/",
	"title": "The Suspect",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ1611 The Suspect\n题目描述  有n个学生，编号0~n-1，m个团体，一个学生可以属于多个团体，或不属于任何团体。一个学生疑似患病，则整个团体疑似患病。 已知0号学生疑似患病，以及每个团体的学生构成情况，求一共有多少学生疑似患病。  解题思路  并查集模板题。维护sum[a]是a所在的集合的人数 注意最后求人数时，需要进行一遍路径压缩，来得到最新的sum[a]  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int par[30010]; int sum[30010];//sum[a]是a所在的集合的人数 int n;//n个学生 int m;//m个团体 int GetRoot(int x) { if(x == par[x]) return x; int px = GetRoot(par[x]); sum[x] = sum[px];//注意这里，从根往下更新 \treturn px; } void Merge(int a, int b) { int ra= GetRoot(a); int rb = GetRoot(b); if(ra == rb) return; par[rb] = ra; sum[ra] += sum[rb]; return; } int main() { int i, j;int k; int a; int b; while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m)){ if(n==0 \u0026amp;\u0026amp; m == 0) break; for(i = 0; i \u0026lt;= n; ++i){ sum[i] = 1; par[i] = i; } for(i = 0; i \u0026lt; m; ++i){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); scanf(\u0026#34;%d\u0026#34;, \u0026amp;a);//每个团体有k个人，先拿出一个，其它的人和他Merge \tfor(j = 1; j \u0026lt; k ;++j){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;b); Merge(a, b); } } GetRoot(0); printf(\u0026#34;%d\\n\u0026#34;, sum[0]); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E4%BF%AE%E5%A4%8D%E5%85%AC%E8%B7%AF/",
	"title": "修复公路",
	"tags": [],
	"description": "",
	"content": "题目链接 洛谷 修复公路\n题目描述  给出A地区的村庄数N，和公路数M，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。 问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）  解题思路  将修复公路的操作按照时间排序。维护记录集合中元素数目的并查集。 sum[GetRoot(a)]表示a所在的集合的元素个数，如果元素个数等于总村庄数，则全部连通。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;cstdlib\u0026gt;using namespace std; const int MAX = 1000; int parent[MAX + 10]; int sum[MAX + 10]; struct Part { int x, y, t; }; Part path[100010]; int myCompare(const void* e1, const void* e2); void Merge(int a, int b); int GetRoot(int a); bool Query(int a, int b); int main() { int N, M; //N村庄，M公路 \tscanf(\u0026#34;%d%d\u0026#34;, \u0026amp;N, \u0026amp;M); int T = -1; for (int i = 0; i \u0026lt; M; ++i) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;path[i].x, \u0026amp;path[i].y, \u0026amp;path[i].t); } bool flag = 0; qsort(path, M, sizeof(Part), myCompare);//按时间从小到大排序 \tfor (int i = 0; i \u0026lt;= N; ++i) { parent[i] = i; sum[i] = 1; } for (int i = 0; i \u0026lt; M; ++i) { if (!Query(path[i].x, path[i].y)) { Merge(path[i].x, path[i].y); if (sum[GetRoot(path[i].x)] == N) { T=path[i].t; break; } } } printf(\u0026#34;%d\\n\u0026#34;, T); } int myCompare(const void* e1, const void* e2) { const Part* p1 = (const Part*)e1; const Part* p2 = (const Part*)e2; if (p1-\u0026gt;t \u0026lt; p2-\u0026gt;t) return -1; else return 1; } int GetRoot(int a) { if (a != parent[a]) { parent[a] = GetRoot(parent[a]); } return parent[a]; } void Merge(int a, int b) { int rb = GetRoot(b); int ra = GetRoot(a); parent[rb] = ra; sum[ra] += sum[rb]; //根节点维护这个集合元素的总个数 \treturn; } bool Query(int a, int b) { return GetRoot(a) == GetRoot(b); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/",
	"title": "导弹拦截",
	"tags": [],
	"description": "",
	"content": "题目链接 导弹拦截\n题目描述  求最长不上升子序列长度和最长上升子序列长度  解题思路  以最长上升子序列为例，传统方法是O(n^2)的，但是可以优化成O(nlog(n))。 首先，做法是两重循环，第一重循环枚举x，这个复杂度无法省掉。第二重循环是找出在x之前，a值大于a[x]的最大dp值。 第二重循环可以通过二分枚举dp值来实现。 需要维护一个数组r[],r[i]是在已经走过的这些元素中，长度为i的LIS最小以什么数结尾。那么，满足r[mid]\u0026lt;a[x]的mid值，都是候选解。 利用二分枚举求出其中最大的即可。 需要维护数组r[],在求出dp[x]之后，把r[dp[x]]设成min(r[dp[x]],a[x])即可。 可以使用upper_bound()函数，但是这里为了训练手写二分枚举，就没用板子。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int a[100010];//导弹的高度 int dp1[100010];//dp1[i]是从第1~第i个以第i结尾的最长不上升子序列长度。 int r1[100010];//在已经走过的这些元素中，长度为i的最长不上升子序列长度最大以什么数结尾。 int dp2[100010];//dp2[i]是从第1~第i个以第i结尾的最长上升子序列长度。 int r2[100010];//在已经走过的这些元素中，长度为i的LIS最小以什么数结尾。  int n; void bin_check1(int x); void bin_check2(int x); int main() { int i, j; n = 1; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[n]) != EOF) { n++; } n--; dp1[1] = 1; r1[1] = a[1]; for (i = 2; i \u0026lt;= n; ++i) { bin_check1(i); } int ans1 = 0; for (i = 1; i \u0026lt;= n; ++i) { ans1 = max(ans1, dp1[i]); } dp2[1] = 1; r2[1] = a[1]; for (i = 2; i \u0026lt;= n; ++i) { bin_check2(i); } int ans2 = 0; for (i = 1; i \u0026lt;= n; ++i) { ans2 = max(ans2, dp2[i]); } printf(\u0026#34;%d\\n\u0026#34;, ans1); printf(\u0026#34;%d\\n\u0026#34;, ans2); return 0; } /* 二分猜测答案 */ void bin_check1(int x) { int left = 1; int right = x - 1; int ans = 0; int mid; //二分枚举dp1[x]的可能解  while (left \u0026lt;= right) { //猜测一个dp1值为mid  mid = (left + right) / 2; if (r1[mid] != 0 \u0026amp;\u0026amp; r1[mid] \u0026gt;= a[x]) { ans = mid; left = mid + 1; } else { right = mid - 1; } } dp1[x] = ans + 1; //维护r1数组，特殊处理等于0的情况。  if (r1[dp1[x]] == 0) { r1[dp1[x]] = a[x]; } else { r1[dp1[x]] = max(r1[dp1[x]], a[x]); } return; } /* 二分猜测答案 */ void bin_check2(int x) { int left = 1; int right = x - 1; int ans = 0; int mid; //二分枚举dp2[x]的可能解  while (left \u0026lt;= right) { //猜测一个dp2值为mid  mid = (left + right) / 2; if (r2[mid] != 0 \u0026amp;\u0026amp; r2[mid] \u0026lt; a[x]) { ans = mid; left = mid + 1; } else { right = mid - 1; } } dp2[x] = ans + 1; //维护r2数组，特殊处理等于0的情况。  if (r2[dp2[x]] == 0) { r2[dp2[x]] = a[x]; } else { r2[dp2[x]] = min(r2[dp2[x]], a[x]); } return; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/",
	"title": "最长公共子序列",
	"tags": [],
	"description": "",
	"content": "题目链接 最长公共子序列\n题目描述  给出1-n的两个排列P1和P2，求它们的最长公共子序列长度  解题思路  此题用一般的求最长公共子序列长度的算法是O(n^2)的，会超时。应该用O(nlog(n))的算法。 本题中P1和P2是两个排列，因此序列中没有重复元素，可以考虑一个神转化。 首先，将P1的序列重新编号。例如\u0026quot;32145\u0026quot;中，3对应1、2对应2、1对应3、4对应4、5对应5。然后用新编号改变P2,例如\u0026quot;12345\u0026quot;改变成\u0026quot;32145\u0026rdquo;。 此时，P2串里面每一个上升的子序列，都唯一对应P1串一个子序列。 求P2串最长上升子序列有O(nlog(n))的算法。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int a[100010];//存储p1串 int b[100010];//读入p2串，并按新编号转化 int mapp[100010];//重新编号，mapp[a[i]]=i int n; int dp[100010];//dp[i]是从第1~第i个以第i结尾的最长上升子序列长度。 int r[100010];//在已经走过的这些元素中，长度为i的LIS最小以什么数结尾。 void bin_check(int x); int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int i; for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); mapp[a[i]] = i;//新的对应  } for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); b[i] = mapp[b[i]];//用新的对应，转化P2串  } dp[1] = 1; r[1] = b[1]; for (i = 2; i \u0026lt;= n; ++i) { bin_check(i); } int ans = 0; for (i = 1; i \u0026lt;= n; ++i) { ans = max(ans, dp[i]); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } void bin_check(int x) { int left = 1; int right = x - 1; int mid = 0; int ans = 0; while (left \u0026lt;= right) { mid = (left + right) / 2; if (r[mid] != 0 \u0026amp;\u0026amp; r[mid] \u0026lt; b[x]) { ans = mid; left = mid + 1; } else { right = mid - 1; } } dp[x] = ans + 1; if (r[dp[x]] == 0) { r[dp[x]] = b[x]; } else { r[dp[x]] = min(r[dp[x]], b[x]); } return; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/%E8%9A%AF%E8%9A%93/",
	"title": "蚯蚓",
	"tags": [],
	"description": "",
	"content": "题目链接 蚯蚓\n题目描述  见链接。  解题思路  如果直接用优先队列会超时。 首先考虑：没有被切过的蚯蚓，只要开始时按从大到小排序，那么今后的任意时刻，因为每次增加长度相同，所以一定是排在前面的先被切。 被切过的蚯蚓分成两部分，较长的和较短的。对于较长的，先被切的一定比后被切的长。对于较短的，也如此。 可以维护三个队列，队列1表示最开始的蚯蚓，队列2表示每一次被切的蚯蚓被分开的较长的那一部分，队列3表示每一次被切的蚯蚓被分开的较短的那一部分。 因为队列1的元素是按时间顺序出队，队列2、3的元素是按时间顺序入队，所以对于增量的计算我们可以按照蚯蚓在队列中的标号。 代码书写时，三个队列可用队列数组表示，这样有利于用循环进行枚举。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; const int MAXN = 1e7; int n, m, q, T; double u, v, p; //三个队列 int que[4][MAXN]; //每个队列的头尾坐标 int head[4]; int tail[4]; int length[MAXN];//length[i]记录i时刻被切的蚯蚓长度，在输出答案时用 int finLength[MAXN];//finLength[i]记录m秒后，排序后的蚯蚓长度，在输出答案时用  int getLength(int t); void printAns(); int main() { scanf(\u0026#34;%d%d%d%lf%lf%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q, \u0026amp;u, \u0026amp;v, \u0026amp;T); p = u / v; int i, j; for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;que[1][i]); } head[1] = head[2] = head[3] = 1; tail[1] = n + 1; tail[2] = tail[3] = 1; sort(que[1] + head[1], que[1] + tail[1], greater\u0026lt;int\u0026gt;()); int x; int lb, lc; for (i = 1; i \u0026lt;= m; ++i) { x = getLength(i); lb = (int)floor(x * p); lc = x - lb; if (lb \u0026lt; lc) swap(lb, lc); que[2][tail[2]++] = lb; que[3][tail[3]++] = lc; } printAns(); return 0; } int getLength(int t) { int num = 0; int sum = 0; for (int i = 1; i \u0026lt;= 3; ++i) { if (head[i] \u0026lt; tail[i] \u0026amp;\u0026amp; i == 1 \u0026amp;\u0026amp; (que[i][head[i]] + (t - 1) * q \u0026gt; sum)) { sum = que[i][head[i]] + (t - 1)* q; num = i; } else if (head[i]\u0026lt;tail[i] \u0026amp;\u0026amp; ( (que[i][head[i]] + (t - 1 - head[i]) * q) \u0026gt; sum) ) { sum = que[i][head[i]] + (t - 1 - head[i]) * q; num = i; } } length[t] = sum; head[num]++; return sum; } void printAns() { int i, j; for (i = 1; i \u0026lt;= m / T; ++i) { printf(\u0026#34;%d \u0026#34;, length[i * T]); } printf(\u0026#34;\\n\u0026#34;); int num = 0; for (i = 1; i \u0026lt;= 3; ++i) { for (j = head[i]; j \u0026lt; tail[i]; ++j) { if (i == 1) { finLength[++num] = que[i][j] + m * q; } else { finLength[++num] = que[i][j] + (m - j) * q; } } } sort(finLength + 1, finLength + 1 + num, greater\u0026lt;int\u0026gt;()); for (i = 1; i \u0026lt;= (n + m) / T; ++i) { printf(\u0026#34;%d \u0026#34;, finLength[T * i]); } printf(\u0026#34;\\n\u0026#34;); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/",
	"title": "装箱问题",
	"tags": [],
	"description": "",
	"content": "题目链接 装箱问题\n题目描述  有一个箱子容量为V，同时有n个物品，每个物品有一个体积（正整数）。要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。  解题思路  可转化为01背包问题。即求如何装，使箱子占有空间最大，总空间减去最大占有空间，即为最小剩余空间。此题可看成物品的价值等于物品体积。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int w[40];//存体积，也相当于价值 int dp[20010];//滚动数组，dp[i][j]计算前i个物品，体积j的背包，装的最大占有空间。其中i被省略。 int V;//容量 int n;//n个物品 int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;V); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int i; int j; for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); } for (i = w[1]; i \u0026lt;= V; ++i) { dp[i] = w[1]; } //滚动数组dp  for (i = 2; i \u0026lt;= n; ++i) { for (j = V; j \u0026gt;= w[i]; --j) { dp[j] = max(dp[j], dp[j - w[i]] + w[i]); } } int ans = 0; for (i = 1; i \u0026lt;= V; ++i) { ans = max(dp[i], ans); } ans = V - ans; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%87%87%E8%8D%AF/",
	"title": "采药",
	"tags": [],
	"description": "",
	"content": "题目链接 采药\n题目描述  山洞里有药，每种药有一定价值，和需要的采药时间。已知：T代表总共能够用来采药的时间，M代表山洞里的草药的数目，求最多能采药的价值？  解题思路  标准的01背包问题。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int T;//采药时间 int M;//草药数目 int wgh[110]; int val[110]; int dp[1010]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;T, \u0026amp;M); int i, j; for (i = 1; i \u0026lt;= M; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;wgh[i], \u0026amp;val[i]); } for (i = wgh[1]; i \u0026lt;= T; ++i) { dp[i] = val[1]; } for (i = 2; i \u0026lt;= M; ++i) { for (j = T; j \u0026gt;= wgh[i]; --j) { dp[j] = max(dp[j], dp[j - wgh[i]] + val[i]); } } int ans = 0; for (i = 1; i \u0026lt;= T; ++i) { ans = max(ans, dp[i]); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4/",
	"title": "银河英雄传说",
	"tags": [],
	"description": "",
	"content": "题目链接 洛谷 银河英雄传说\n题目描述  见链接。实际上和Cube stacking类似。  解题思路  类似于Cube stacking。利用并查集，维护sum[]数组和under[]数组。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;using namespace std; const int MAX = 30000; int parent[MAX + 10];//parent[i]是i的父节点 int sum[MAX + 10];//sum[i]是以i为根的集合的元素个数 int under[MAX + 10];//under[i]是i下面有的个数 int GetRoot(int a); void Merge(int a, int b); bool Query(int a, int b); int main() { for (int i = 1; i \u0026lt;= MAX; ++i) { parent[i] = i; sum[i] = 1; under[i] = 0; } int T = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); char c[2]; int x; int y; while (T--) { scanf(\u0026#34;%s%d%d\u0026#34;, c, \u0026amp;x, \u0026amp;y); if (c[0] == \u0026#39;M\u0026#39;) { Merge(x, y); } else { if (Query(x, y)) { printf(\u0026#34;%d\\n\u0026#34;, abs(under[x] - under[y]) - 1); } else { printf(\u0026#34;-1\\n\u0026#34;); } } } return 0; } int GetRoot(int a) { if (a == parent[a]) return a; int ra = GetRoot(parent[a]); under[a] += under[parent[a]]; parent[a] = ra; return ra; } void Merge(int a, int b)//把a放到b上 { int ra = GetRoot(a); int rb = GetRoot(b); parent[ra] = rb; under[ra] = sum[rb]; sum[rb] += sum[ra]; return; } bool Query(int a, int b) { return GetRoot(a) == GetRoot(b); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E9%A3%9F%E7%89%A9%E9%93%BE/",
	"title": "食物链",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ1182 食物链\n题目描述  动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这N个动物所构成的食物链关系进行描述： 第一种说法是\u0026quot;1 X Y\u0026rdquo;，表示X和Y是同类。 第二种说法是\u0026quot;2 X Y\u0026rdquo;，表示X吃Y。 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。  1） 当前的话与前面的某些真的话冲突，就是假话； 2） 当前的话中X或Y比N大，就是假话； 3） 当前的话表示X吃X，就是假话。   你的任务是根据给定的N（1 \u0026lt;= N \u0026lt;= 50,000）和K句话（0 \u0026lt;= K \u0026lt;= 100,000），输出假话的总数。  解题思路  利用带权并查集，把\u0026quot;可以判断出捕食关系的动物\u0026quot;放到同一集合中。 在Merge()和GetRoot()函数中更新子结点与根节点的捕食关系。 捕食关系类似于向量加减，可通过画向量图的方式计算结点间的关系。  代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;stack\u0026gt;using namespace std; const int MAXN = 50010; int parent[MAXN]; int relation[MAXN];//x吃y是1，x被y吃是2，x与y是同类是0  //把x与y的关系，看成是x指向y的向量，用向量的运算做 int n;//n个动物 void Merge(int a, int b, int r); int GetRoot(int x); bool Query(int a, int b); int main() { int i, j; int k; int sum = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); int r, x, y; for(i = 1; i \u0026lt;= n; ++i){ parent[i] = i; } for(i = 0; i \u0026lt; k; ++i){ scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;r, \u0026amp;x, \u0026amp;y); if(x \u0026gt; n || y \u0026gt; n){ sum++;\t} else if(x == y \u0026amp;\u0026amp; r == 2){ //注意，题目中的r和我们定义的relation不同，一定要审题+仔细 \tsum++; } else{ if(!Query(x, y)){ Merge(x, y, r - 1);\t} else{ if((relation[x] - relation[y] + 3)%3 != (r - 1)){ sum++; } } } } printf(\u0026#34;%d\\n\u0026#34;, sum); } int GetRoot(int x) { if(x == parent[x]) return x; int px = GetRoot(parent[x]); relation[x] = (relation[parent[x]] + relation[x])%3; parent[x] = px; return px; } void Merge(int a, int b, int r) { int pa = GetRoot(a); int pb = GetRoot(b); if(pa != pb){ //注意这里，如果相同就不能更新关系 \t//其实每次Merge()前会判断是否在同一棵树上，但是加上更保险 \tparent[pb] = pa; relation[pb] = (relation[a] - (relation[b] + r) + 6)%3; } return ; } bool Query(int a, int b) { return GetRoot(a) == GetRoot(b); } "
}]
[
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E5%8C%BA%E9%97%B4%E7%AD%9B%E6%B3%95/",
	"title": "区间筛法",
	"tags": [],
	"description": "",
	"content": "题目描述 求区间[a, b)内素数个数？其中a, b范围为1e12, b-a的范围是1e6\n解题思路  利用素数筛法。b以内的合数的最小质因数一定不超过sqrt(b)。因此在[2, sqrt(b))上筛素数的同时，也可将[a,b)中的合数筛去。 因为题中a,b较大，所以构建[a, b)的表需要映射成0~b-a。 题中的乘法需要long long范围，因此可将所有数都用long long范围。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; typedef long long ll; const long long MAXN = 1e6 + 10; bool is_prime[MAXN];//is_prime[i - a]判断i是否为素数，筛[a, b) bool is_prime_small[MAXN];//is_prime_small[i]判断i是否为素数,筛[2, sqrt(b)) /* 对区间[a, b)内的整数进行筛法 */ ll segment_sieve(ll a, ll b) { for(ll i = 0; i * i \u0026lt; b; ++i){ is_prime_small[i] = true; } for(ll i = 0, j = b - a; i \u0026lt; j; ++i){ is_prime[i] = true; } for(ll i = 2; i * i \u0026lt; b; ++i){ if(is_prime_small[i]){ //筛[2, sqrt(b)) for(ll j = 2*i; j * j \u0026lt; b; j += i){ is_prime_small[j] = false; } //筛[a, b) for(ll j = max((a + i - 1)/i, 2LL)*i; j \u0026lt; b; j += i){ is_prime[j - a] = false; } } } ll ans = 0; for(ll i = 0, j = b - a; i \u0026lt; j; ++i){ if(is_prime[i]) ans++; } return ans; } int main() { ll a, b; scanf(\u0026quot;%lld%lld\u0026quot;, \u0026amp;a, \u0026amp;b); ll ans = segment_sieve(a, b); printf(\u0026quot;%lld\\n\u0026quot;, ans); return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/carmichael-numbers/",
	"title": "Carmichael Numbers",
	"tags": [],
	"description": "",
	"content": "题目链接 Carmichael Numbers\n题目描述 如果对任意的 1 \u0026lt; x \u0026lt; n 都有 x^n≡x(mod n)成立的合数n称为Carmichael Numbers。给出一些整数n,请判断是否为Carmichael Numbers，其中2 \u0026lt; n \u0026lt; 65000\n解题思路  首先判断n是否为合数 利用快速幂计算x^n  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; typedef long long ll; /* 判断是否为质数 */ bool is_primer(int n) { for(int i = 2; i*i \u0026lt;= n; ++i){ if(n %i == 0) return false; } return true; } /* 快速幂 */ ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while(n \u0026gt; 0){ if(n \u0026amp; 1){ res = res * x % mod; } x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } int main() { ll n; bool flag = 1; ll ans; while(1){ flag = 1; scanf(\u0026quot;%lld\u0026quot;, \u0026amp;n); if(!n) break; //如果n是质数 if(is_primer((int)n)){ printf(\u0026quot;%lld is normal.\\n\u0026quot;, n); } else{ for(ll x = 2; x \u0026lt; n; ++x){ ans = mod_pow(x, n, n); if(ans != x){ flag = 0; break; } } if(flag) printf(\u0026quot;The number %lld is a Carmichael number.\\n\u0026quot;, n); else printf(\u0026quot;%lld is normal.\\n\u0026quot;, n); } } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E5%9F%83%E5%BC%8F%E7%AD%9B%E6%B3%95/",
	"title": "埃式筛法",
	"tags": [],
	"description": "",
	"content": "题目描述 给定数n，求n以内的素数个数\n解题思路  利用筛法求素数，首先假设3~n均为素数。由于对于一个数i，如果i是素数，则2i,3i\u0026hellip;\u0026hellip;均不是素数。利用此方法筛选后，剩下的就是素数  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; const int MAXN = 1000010; int prime[MAXN];//prime[i]为n的第i个素数 bool is_prime[MAXN]; /* 素数筛法，返回n以内的素数的个数 */ int sieve(int n) { int p = 0; int i, j; for(i = 0; i \u0026lt;= n; ++i){ is_prime[i] = true; } is_prime[0] = is_prime[1] = false; for(i = 2; i \u0026lt;= n; ++i){ if(is_prime[i]){ prime[++p] = i; for(j = 2*i; j \u0026lt;= n; j += i){ is_prime[j] = false; } } } return p; } int main() { int n; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); int ans = sieve(n); printf(\u0026quot;%d\\n\u0026quot;, ans); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A/",
	"title": "素数判定",
	"tags": [],
	"description": "",
	"content": "题目描述 给定数n，判断n是否为素数；求n的约数；求n的整数分解形式\n解题思路  枚举n可能的约数  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;map\u0026gt; using namespace std; /* 素数测试判断素数 */ bool isPrime1(int n) { if(n == 1) return false; int k = sqrt(n); for (int i = 2; i \u0026lt;= k; ++i){ if(n % i == 0) return false; } return true; } /* 约数枚举 */ vector\u0026lt;int\u0026gt; divisor(int n) { vector\u0026lt;int\u0026gt; res; int k = sqrt(n); for(int i = 1; i \u0026lt;= k; ++i){ if(n % i == 0){ res.push_back(i); if(i != n/i) res.push_back(n/i); } } return res; } /* 整数分解 */ map\u0026lt;int, int\u0026gt; prime_factor(int n){ map\u0026lt;int, int\u0026gt; res; //记录n的每个约数及该约数的个数 //由于整数分解时n是变的，因此用i*i \u0026lt;= n判断 for(int i = 2; i * i \u0026lt;= n; ++i){ while(n % i == 0){ ++res[i]; n /= i; } } if(n != 1) res[n] = 1; return res; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E5%8F%8C%E5%85%AD/",
	"title": "双六",
	"tags": [],
	"description": "",
	"content": "题目描述 一个双六上面有向前向后无线延续的格子，每个格子都写有整数。其中0号是起点，1号是终点。输入整数a和b，一个骰子只有a,b,-a,-b四个 整数。问抛出四个数多少次可到达终点？如果解不唯一，输出一组即可。如果无解，输出-1。\n解题思路  即求整数x,y使得ax+by=1。 有解条件为gcd(a, b)=1。 利用扩展的欧几里得算法可求解。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; /* 扩展欧几里得算法，在求gcd(a, b)的同时， 求出一对(x, y)满足a*x + b*y = gcd(a, b) */ int extgcd(int a, int b, int\u0026amp; x, int\u0026amp; y) { int d = a; if(b != 0){ d = extgcd(b, a%b, y, x); y -= (a/b) * x; } else{ x = 1; y = 0; } return d; } int main() { int a, b; int x, y; int n1, n2, n3, n4; // 对应a, b, -a, -b的个数 scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b); int d; d = extgcd(a, b, x, y); if(d != 1){ printf(\u0026quot;-1\\n\u0026quot;); } else{ n1 = n2 = n3 = n4 = 0; if(x \u0026gt; 0) n1 = x; else n3 = -x; if(y \u0026gt; 0) n2 = y; else n4 = -y; printf(\u0026quot;%d%d%d%d\\n\u0026quot;, n1, n2, n3, n4); } } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/%E7%BA%BF%E6%AE%B5%E4%B8%8A%E7%9A%84%E6%A0%BC%E7%82%B9%E6%95%B0/",
	"title": "线段上的格点数",
	"tags": [],
	"description": "",
	"content": "题目描述 给定平面上的两个格点P和Q的坐标。求线段PQ除端点以外一共有多少个格点？\n解题思路  答案是线段x轴投影长度与y轴投影长度的最大公约数-1 注意特判P与Q重合的情况  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; /*辗转相除法，求a和b的最大公约数*/ int gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b); } int main() { int x1, y1, x2, y2; scanf(\u0026quot;%d%d%d%d\u0026quot;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2); int dx = abs(x1 - x2); int dy = abs(y1 - y2); int ans; if(!dx \u0026amp;\u0026amp; !dy){ //特判dx==0\u0026amp;\u0026amp;dy==0的情况 ans = 0; } else{ ans = gcd(dx, dy) - 1; } printf(\u0026quot;%d\\n\u0026quot;, ans); } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E6%95%B0%E8%AE%BA/",
	"title": "数论",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E7%BA%BF%E6%AE%B5%E6%A0%91/%E5%8C%BA%E9%97%B4%E6%8A%91%E6%88%96/",
	"title": "ZGOJ1561 区间抑或",
	"tags": [],
	"description": "",
	"content": "题目链接 打不开了\n题目描述  忘了  解题思路  利用线段树，区间操作注意用延迟更新，包括向下更新和向上更新。 注意要用unsigned int。  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; int a[100010]; unsigned int b; int n;//n个数 int m;//m个查询 struct Node { int L, R; int sum;//区间的抑或和 int lazy; int val; int Mid() { return (L + R) / 2; } }; Node tree[400010]; void build_tree(int root, int l, int r) { tree[root].L = l; tree[root].R = r; tree[root].lazy = 0; tree[root].val = 0; if (l == r) { tree[root].sum = a[l]; tree[root].val = a[l]; return; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); build_tree(lc, l, mid); build_tree(rc, mid + 1, r); tree[root].sum = tree[lc].sum ^ tree[rc].sum; } int query_tree(int root, int l, int r) { if (tree[root].L \u0026lt;= l \u0026amp;\u0026amp; tree[root].R \u0026gt;= r \u0026amp;\u0026amp; tree[root].lazy) { if ((r - l +1) % 2) { return tree[root].val; } else { return 0; } } if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { return tree[root].sum; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); if (r \u0026lt;= mid) { return query_tree(lc, l, r); } else if (l \u0026gt; mid) { return query_tree(rc, l, r); } else { return (query_tree(lc, l, mid) ^ query_tree(rc, mid + 1, r)); } } void change_tree(int root, int l, int r, int num) { if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { tree[root].val = num; tree[root].lazy = 1; if ((r - l +1 ) % 2) { tree[root].sum = num; } else tree[root].sum = 0; return; } int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; int mid = tree[root].Mid(); if (tree[root].lazy) { tree[root].lazy = 0; tree[lc].lazy = tree[rc].lazy = 1; tree[lc].val = tree[rc].val = tree[root].val; if ((tree[lc].R - tree[lc].L + 1) % 2) { tree[lc].sum = tree[lc].val; } else tree[lc].sum = 0; if ((tree[rc].R - tree[rc].L + 1) % 2) { tree[rc].sum = tree[rc].val; } else tree[rc].sum = 0; } if (r \u0026lt;= mid) { change_tree(lc, l, r, num); } else if (l \u0026gt; mid) { change_tree(rc, l, r, num); } else { change_tree(lc, l, mid, num); change_tree(rc, mid + 1, r, num); } tree[root].sum = tree[lc].sum ^ tree[rc].sum; //tree[root].lazy = 0; return; } int main() { int T; scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); int i, j; unsigned int ans;//注意要用unsigned int !!! while (T--) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); memset(tree, 0, sizeof(tree)); memset(a, 0, sizeof(a)); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%u\u0026quot;, \u0026amp;b); a[i] = (int)b; } build_tree(1, 1, n); char s[3]; int a, b, x; for (i = 1; i \u0026lt;= m; ++i) { scanf(\u0026quot;%s\u0026quot;, s); if (s[0] == 'C') { scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;x); change_tree(1, a, b, x); } else { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b); ans = query_tree(1, a, b); printf(\u0026quot;%u\\n\u0026quot;, ans); } } printf(\u0026quot;\\n\u0026quot;); } return 0; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/",
	"title": "HomePage",
	"tags": [],
	"description": "",
	"content": "欢迎来到ZJQ的博客  本博客是基于hugo框架搭建的静态博客。本人第一次搭博客，动态博客也写不来，而且也设计不出这些主题。 博客内容以学习为主，经初步构思，本博客主要用来记录算法、计算机知识、电脑使用知识等。 佛系更新，更新快说明在认真学习ing，更新慢说明在摸鱼\u0026hellip;\u0026hellip; 祝大家开心快乐，学习进步！  "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E7%BA%BF%E6%AE%B5%E6%A0%91/majors_poster/",
	"title": "POJ2528 Mayor&#39;s poster",
	"tags": [],
	"description": "",
	"content": "题目链接 POJ2528 Mayor\u0026rsquo;s poster\n题目描述  用多张海报贴一面墙，求贴完后有几张海报是可见的（完全可见+部分可见）。 题目有多组数据。 对于每组数据有n个海报，每个海报给定左、右端点，并按照贴的顺序给出。  解题思路  利用线段树，注意处理顺序是由外层到内层。因为外层覆盖的区间会影响内层的可见情况，而内层覆盖的区间不会影响外层的可见情况。 注意延迟更新  代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; struct Node { int L, R; bool covered; int Mid() { return L + (R - L) / 2; } }; struct Line { int s, e; }; Line poster[10010];//记录海报 int disc[40010];//用于离散化 Node tree[160010];//线段树 int point[40010];//记录海报的两个端点，用于离散化 int point_num;//记录去重后的端点个数 void build_tree(int root, int l, int r); bool query_tree(int root, int l, int r); int main() { int c; int n;//c个样例，n个海报 scanf(\u0026quot;%d\u0026quot;, \u0026amp;c); int ans; int i, j; while (c--) { ans = 0; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;poster[i].s, \u0026amp;poster[i].e); point[2 * i] = poster[i].s; point[2 * i + 1] = poster[i].e; } sort(point, point + 2 * n); point_num = unique(point, point + 2 * n) - point; int dcnt = 0; disc[dcnt] = point[0]; dcnt++; //离散化，要把两个端点中间的区间也离散化成一个区间， //因此如果(point[i]-point[i-1]\u0026gt;1)，就把point[i-1]+1当一个新区间 for(i = 1; i \u0026lt; point_num; ++i){ if( (point[i] - point[i-1]) \u0026gt; 1){ disc[dcnt] = point[i-1]+1;\tdcnt++; } disc[dcnt] = point[i]; dcnt++; } build_tree(1, 1, dcnt); int nl, nr; for(i = n - 1; i \u0026gt;= 0; --i){ nl = lower_bound(disc, disc + dcnt, poster[i].s) - disc + 1; nr = lower_bound(disc, disc + dcnt, poster[i].e) - disc + 1; if(!query_tree(1, nl, nr) ){ ans++; } } printf(\u0026quot;%d\\n\u0026quot;, ans); } } void build_tree(int root, int l, int r) { tree[root].L = l; tree[root].R = r; tree[root].covered = 0; if (l == r) return; int mid = tree[root].Mid(); build_tree((root \u0026lt;\u0026lt; 1), l, mid); build_tree((root \u0026lt;\u0026lt; 1) | 1, mid + 1, r); return; } bool query_tree(int root, int l, int r) { bool flag = 0; if (tree[root].L == l \u0026amp;\u0026amp; tree[root].R == r) { flag = tree[root].covered; tree[root].covered = 1; return flag; } if(tree[root].L \u0026lt;= l \u0026amp;\u0026amp; tree[root].R \u0026gt;= r \u0026amp;\u0026amp; tree[root].covered){ //如果当前区间包裹了要查询的区间，且已经被覆盖了，就直接返回true, //因为你第一个是延迟更新，你这里不判断，就跑到下面了 //注意这里，错了两次了！！！ return 1; } int mid = tree[root].Mid(); int lc = (root \u0026lt;\u0026lt; 1); int rc = (root \u0026lt;\u0026lt; 1) | 1; if (r \u0026lt;= mid) { flag = query_tree(lc, l, r); } else if (l \u0026gt; mid) { flag = query_tree(rc, l, r); } else { flag = query_tree(lc, l, mid) \u0026amp; query_tree(rc, mid + 1, r); } //注意更新cover的状态 tree[root].covered = tree[lc].covered \u0026amp; tree[rc].covered; return flag; } "
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/%E7%BA%BF%E6%AE%B5%E6%A0%91/",
	"title": "线段树",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/algorithms/",
	"title": "算法",
	"tags": [],
	"description": "",
	"content": "简介  本栏目期望能够长期更新，用于记录算法和数据结构。 主要内容是做过的题和代码。 由于本人从大学才开始接触算法，并且在学校被虐的死去活来QAQS，因此题目多为模板题。  "
},
{
	"uri": "https://zhujiaqi9905.github.io/machine_learning/",
	"title": "机器学习",
	"tags": [],
	"description": "",
	"content": "简介  以记录机器学习的代码实现为主 更新时间未知，因为偶还没开始学\u0026hellip;\u0026hellip;  "
},
{
	"uri": "https://zhujiaqi9905.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://zhujiaqi9905.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]